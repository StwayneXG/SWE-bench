file,method_name,new_method_name,start_line,end_line,original_code,code,var
./sympy/combinatorics/permutations.py,_af_pow,compute_permutation_power,169,211,"def _af_pow(a, n):
    """"""
    Routine for finding powers of a permutation.

    Examples
    ========

    >>> from sympy.combinatorics.permutations import Permutation, _af_pow
    >>> Permutation.print_cyclic = False
    >>> p = Permutation([2, 0, 3, 1])
    >>> p.order()
    4
    >>> _af_pow(p._array_form, 4)
    [0, 1, 2, 3]
    """"""
    if n == 0:
        return list(range(len(a)))
    if n < 0:
        return _af_pow(_af_invert(a), -n)
    if n == 1:
        return a[:]
    elif n == 2:
        b = [a[i] for i in a]
    elif n == 3:
        b = [a[a[i]] for i in a]
    elif n == 4:
        b = [a[a[a[i]]] for i in a]
    else:
        b = list(range(len(a)))
        while 1:
            if n & 1:
                b = [b[i] for i in a]
                n -= 1
                if not n:
                    break
            if n % 4 == 0:
                a = [a[a[a[i]]] for i in a]
                n = n // 4
            elif n % 2 == 0:
                a = [a[i] for i in a]
                n = n // 2
    return b","def compute_permutation_power(a, n):
    """"""
    Routine for finding powers of a permutation.

    Examples
    ========

    >>> from sympy.combinatorics.permutations import Permutation, _af_pow
    >>> Permutation.print_cyclic = False
    >>> p = Permutation([2, 0, 3, 1])
    >>> p.order()
    4
    >>> _af_pow(p._array_form, 4)
    [0, 1, 2, 3]
    """"""
    if n == 0:
        return list(range(len(a)))
    if n < 0:
        return _af_pow(_af_invert(a), -n)
    if n == 1:
        return a[:]
    elif n == 2:
        b = [a[i] for i in a]
    elif n == 3:
        b = [a[a[i]] for i in a]
    elif n == 4:
        b = [a[a[a[i]]] for i in a]
    else:
        b = list(range(len(a)))
        while 1:
            if n & 1:
                b = [b[i] for i in a]
                n -= 1
                if not n:
                    break
            if n % 4 == 0:
                a = [a[a[a[i]]] for i in a]
                n = n // 4
            elif n % 2 == 0:
                a = [a[i] for i in a]
                n = n // 2
    return b","[{""var"": ""i"", ""rename"": ""index_in_permutation""}, {""var"": ""b"", ""rename"": ""permuted_indices""}]"
./sympy/combinatorics/permutations.py,_af_commutes_with,check_permutation_commutativity,213,230,"def _af_commutes_with(a, b):
    """"""
    Checks if the two permutations with array forms
    given by ``a`` and ``b`` commute.

    Examples
    ========

    >>> from sympy.combinatorics.permutations import _af_commutes_with
    >>> _af_commutes_with([1, 2, 0], [0, 2, 1])
    False

    See Also
    ========

    Permutation, commutes_with
    """"""
    return not any((a[b[i]] != b[a[i]] for i in range(len(a) - 1)))","def check_permutation_commutativity(a, b):
    """"""
    Checks if the two permutations with array forms
    given by ``a`` and ``b`` commute.

    Examples
    ========

    >>> from sympy.combinatorics.permutations import _af_commutes_with
    >>> _af_commutes_with([1, 2, 0], [0, 2, 1])
    False

    See Also
    ========

    Permutation, commutes_with
    """"""
    return not any((a[b[i]] != b[a[i]] for i in range(len(a) - 1)))","[{""var"": ""i"", ""rename"": ""index_position""}]"
./sympy/combinatorics/permutations.py,__new__,create_permutation_from_input,801,925,"def __new__(cls, *args, **kwargs):
    """"""
        Constructor for the Permutation object from a list or a
        list of lists in which all elements of the permutation may
        appear only once.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False

        Permutations entered in array-form are left unaltered:

        >>> Permutation([0, 2, 1])
        Permutation([0, 2, 1])

        Permutations entered in cyclic form are converted to array form;
        singletons need not be entered, but can be entered to indicate the
        largest element:

        >>> Permutation([[4, 5, 6], [0, 1]])
        Permutation([1, 0, 2, 3, 5, 6, 4])
        >>> Permutation([[4, 5, 6], [0, 1], [19]])
        Permutation([1, 0, 2, 3, 5, 6, 4], size=20)

        All manipulation of permutations assumes that the smallest element
        is 0 (in keeping with 0-based indexing in Python) so if the 0 is
        missing when entering a permutation in array form, an error will be
        raised:

        >>> Permutation([2, 1])
        Traceback (most recent call last):
        ...
        ValueError: Integers 0 through 2 must be present.

        If a permutation is entered in cyclic form, it can be entered without
        singletons and the ``size`` specified so those values can be filled
        in, otherwise the array form will only extend to the maximum value
        in the cycles:

        >>> Permutation([[1, 4], [3, 5, 2]], size=10)
        Permutation([0, 4, 3, 5, 1, 2], size=10)
        >>> _.array_form
        [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]
        """"""
    size = kwargs.pop('size', None)
    if size is not None:
        size = int(size)
    ok = True
    if not args:
        return _af_new(list(range(size or 0)))
    elif len(args) > 1:
        return _af_new(Cycle(*args).list(size))
    if len(args) == 1:
        a = args[0]
        if isinstance(a, Perm):
            if size is None or size == a.size:
                return a
            return Perm(a.array_form, size=size)
        if isinstance(a, Cycle):
            return _af_new(a.list(size))
        if not is_sequence(a):
            return _af_new(list(range(a + 1)))
        if has_variety((is_sequence(ai) for ai in a)):
            ok = False
    else:
        ok = False
    if not ok:
        raise ValueError('Permutation argument must be a list of ints, a list of lists, Permutation or Cycle.')
    args = list(args[0])
    is_cycle = args and is_sequence(args[0])
    if is_cycle:
        args = [[int(i) for i in c] for c in args]
    else:
        args = [int(i) for i in args]
    temp = flatten(args)
    if has_dups(temp) and (not is_cycle):
        raise ValueError('there were repeated elements.')
    temp = set(temp)
    if not is_cycle and any((i not in temp for i in range(len(temp)))):
        raise ValueError('Integers 0 through %s must be present.' % max(temp))
    if is_cycle:
        c = Cycle()
        for ci in args:
            c = c(*ci)
        aform = c.list()
    else:
        aform = list(args)
    if size and size > len(aform):
        aform.extend(list(range(len(aform), size)))
    size = len(aform)
    obj = Basic.__new__(cls, aform)
    obj._array_form = aform
    obj._size = size
    return obj","def create_permutation_from_input(cls, *args, **kwargs):
    """"""
        Constructor for the Permutation object from a list or a
        list of lists in which all elements of the permutation may
        appear only once.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False

        Permutations entered in array-form are left unaltered:

        >>> Permutation([0, 2, 1])
        Permutation([0, 2, 1])

        Permutations entered in cyclic form are converted to array form;
        singletons need not be entered, but can be entered to indicate the
        largest element:

        >>> Permutation([[4, 5, 6], [0, 1]])
        Permutation([1, 0, 2, 3, 5, 6, 4])
        >>> Permutation([[4, 5, 6], [0, 1], [19]])
        Permutation([1, 0, 2, 3, 5, 6, 4], size=20)

        All manipulation of permutations assumes that the smallest element
        is 0 (in keeping with 0-based indexing in Python) so if the 0 is
        missing when entering a permutation in array form, an error will be
        raised:

        >>> Permutation([2, 1])
        Traceback (most recent call last):
        ...
        ValueError: Integers 0 through 2 must be present.

        If a permutation is entered in cyclic form, it can be entered without
        singletons and the ``size`` specified so those values can be filled
        in, otherwise the array form will only extend to the maximum value
        in the cycles:

        >>> Permutation([[1, 4], [3, 5, 2]], size=10)
        Permutation([0, 4, 3, 5, 1, 2], size=10)
        >>> _.array_form
        [0, 4, 3, 5, 1, 2, 6, 7, 8, 9]
        """"""
    size = kwargs.pop('size', None)
    if size is not None:
        size = int(size)
    ok = True
    if not args:
        return _af_new(list(range(size or 0)))
    elif len(args) > 1:
        return _af_new(Cycle(*args).list(size))
    if len(args) == 1:
        a = args[0]
        if isinstance(a, Perm):
            if size is None or size == a.size:
                return a
            return Perm(a.array_form, size=size)
        if isinstance(a, Cycle):
            return _af_new(a.list(size))
        if not is_sequence(a):
            return _af_new(list(range(a + 1)))
        if has_variety((is_sequence(ai) for ai in a)):
            ok = False
    else:
        ok = False
    if not ok:
        raise ValueError('Permutation argument must be a list of ints, a list of lists, Permutation or Cycle.')
    args = list(args[0])
    is_cycle = args and is_sequence(args[0])
    if is_cycle:
        args = [[int(i) for i in c] for c in args]
    else:
        args = [int(i) for i in args]
    temp = flatten(args)
    if has_dups(temp) and (not is_cycle):
        raise ValueError('there were repeated elements.')
    temp = set(temp)
    if not is_cycle and any((i not in temp for i in range(len(temp)))):
        raise ValueError('Integers 0 through %s must be present.' % max(temp))
    if is_cycle:
        c = Cycle()
        for ci in args:
            c = c(*ci)
        aform = c.list()
    else:
        aform = list(args)
    if size and size > len(aform):
        aform.extend(list(range(len(aform), size)))
    size = len(aform)
    obj = Basic.__new__(cls, aform)
    obj._array_form = aform
    obj._size = size
    return obj","[{""var"": ""c"", ""rename"": ""constructed_cycle""}, {""var"": ""ai"", ""rename"": ""element_sequence""}, {""var"": ""is_cycle"", ""rename"": ""is_cyclic_representation""}, {""var"": ""ok"", ""rename"": ""is_valid_permutation""}, {""var"": ""i"", ""rename"": ""element_index""}, {""var"": ""a"", ""rename"": ""permutation_input""}, {""var"": ""obj"", ""rename"": ""permutation_instance""}, {""var"": ""temp"", ""rename"": ""flattened_elements_set""}, {""var"": ""ci"", ""rename"": ""cycle_element_indices""}, {""var"": ""size"", ""rename"": ""permutation_length""}, {""var"": ""aform"", ""rename"": ""array_form_representation""}]"
./sympy/combinatorics/permutations.py,_af_new,_create_internal_permutation,928,950,"@staticmethod
def _af_new(perm):
    """"""A method to produce a Permutation object from a list;
        the list is bound to the _array_form attribute, so it must
        not be modified; this method is meant for internal use only;
        the list ``a`` is supposed to be generated as a temporary value
        in a method, so p = Perm._af_new(a) is the only object
        to hold a reference to ``a``::

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Perm
        >>> Perm.print_cyclic = False
        >>> a = [2,1,3,0]
        >>> p = Perm._af_new(a)
        >>> p
        Permutation([2, 1, 3, 0])

        """"""
    p = Basic.__new__(Perm, perm)
    p._array_form = perm
    p._size = len(perm)
    return p","@staticmethod
def _create_internal_permutation(perm):
    """"""A method to produce a Permutation object from a list;
        the list is bound to the _array_form attribute, so it must
        not be modified; this method is meant for internal use only;
        the list ``a`` is supposed to be generated as a temporary value
        in a method, so p = Perm._af_new(a) is the only object
        to hold a reference to ``a``::

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Perm
        >>> Perm.print_cyclic = False
        >>> a = [2,1,3,0]
        >>> p = Perm._af_new(a)
        >>> p
        Permutation([2, 1, 3, 0])

        """"""
    p = Basic.__new__(Perm, perm)
    p._array_form = perm
    p._size = len(perm)
    return p","[{""var"": ""p"", ""rename"": ""permutation_instance""}]"
./sympy/combinatorics/permutations.py,rmul_with_af,multiply_permutation_array_forms,1223,1230,"@staticmethod
def rmul_with_af(*args):
    """"""
        same as rmul, but the elements of args are Permutation objects
        which have _array_form
        """"""
    a = [x._array_form for x in args]
    rv = _af_new(_af_rmuln(*a))
    return rv","@staticmethod
def multiply_permutation_array_forms(*args):
    """"""
        same as rmul, but the elements of args are Permutation objects
        which have _array_form
        """"""
    a = [x._array_form for x in args]
    rv = _af_new(_af_rmuln(*a))
    return rv","[{""var"": ""a"", ""rename"": ""array_forms_list""}, {""var"": ""x"", ""rename"": ""permutation_array_forms""}, {""var"": ""rv"", ""rename"": ""result_permutation_array""}]"
./sympy/combinatorics/permutations.py,mul_inv,multiply_inverse_with_array_form,1232,1238,"def mul_inv(self, other):
    """"""
        other*~self, self and other have _array_form
        """"""
    a = _af_invert(self._array_form)
    b = other._array_form
    return _af_new(_af_rmul(a, b))","def multiply_inverse_with_array_form(self, other):
    """"""
        other*~self, self and other have _array_form
        """"""
    a = _af_invert(self._array_form)
    b = other._array_form
    return _af_new(_af_rmul(a, b))","[{""var"": ""a"", ""rename"": ""inverted_self_array""}, {""var"": ""b"", ""rename"": ""other_array_form""}]"
./sympy/combinatorics/permutations.py,__rmul__,coerce_and_multiply_with_permutation,1240,1242,"def __rmul__(self, other):
    """"""This is needed to coerse other to Permutation in rmul.""""""
    return Perm(other) * self","def coerce_and_multiply_with_permutation(self, other):
    """"""This is needed to coerse other to Permutation in rmul.""""""
    return Perm(other) * self",[]
./sympy/combinatorics/permutations.py,__mul__,compose_permutations,1244,1303,"def __mul__(self, other):
    """"""
        Return the product a*b as a Permutation; the ith value is b(a(i)).

        Examples
        ========

        >>> from sympy.combinatorics.permutations import _af_rmul, Permutation
        >>> Permutation.print_cyclic = False

        >>> a, b = [1, 0, 2], [0, 2, 1]
        >>> a = Permutation(a); b = Permutation(b)
        >>> list(a*b)
        [2, 0, 1]
        >>> [b(a(i)) for i in range(3)]
        [2, 0, 1]

        This handles operands in reverse order compared to _af_rmul and rmul:

        >>> al = list(a); bl = list(b)
        >>> _af_rmul(al, bl)
        [1, 2, 0]
        >>> [al[bl[i]] for i in range(3)]
        [1, 2, 0]

        It is acceptable for the arrays to have different lengths; the shorter
        one will be padded to match the longer one:

        >>> b*Permutation([1, 0])
        Permutation([1, 2, 0])
        >>> Permutation([1, 0])*b
        Permutation([2, 0, 1])

        It is also acceptable to allow coercion to handle conversion of a
        single list to the left of a Permutation:

        >>> [0, 1]*a # no change: 2-element identity
        Permutation([1, 0, 2])
        >>> [[0, 1]]*a # exchange first two elements
        Permutation([0, 1, 2])

        You cannot use more than 1 cycle notation in a product of cycles
        since coercion can only handle one argument to the left. To handle
        multiple cycles it is convenient to use Cycle instead of Permutation:

        >>> [[1, 2]]*[[2, 3]]*Permutation([]) # doctest: +SKIP
        >>> from sympy.combinatorics.permutations import Cycle
        >>> Cycle(1, 2)(2, 3)
        (1 3 2)

        """"""
    a = self.array_form
    b = other.array_form
    if not b:
        perm = a
    else:
        b.extend(list(range(len(b), len(a))))
        perm = [b[i] for i in a] + b[len(a):]
    return _af_new(perm)","def compose_permutations(self, other):
    """"""
        Return the product a*b as a Permutation; the ith value is b(a(i)).

        Examples
        ========

        >>> from sympy.combinatorics.permutations import _af_rmul, Permutation
        >>> Permutation.print_cyclic = False

        >>> a, b = [1, 0, 2], [0, 2, 1]
        >>> a = Permutation(a); b = Permutation(b)
        >>> list(a*b)
        [2, 0, 1]
        >>> [b(a(i)) for i in range(3)]
        [2, 0, 1]

        This handles operands in reverse order compared to _af_rmul and rmul:

        >>> al = list(a); bl = list(b)
        >>> _af_rmul(al, bl)
        [1, 2, 0]
        >>> [al[bl[i]] for i in range(3)]
        [1, 2, 0]

        It is acceptable for the arrays to have different lengths; the shorter
        one will be padded to match the longer one:

        >>> b*Permutation([1, 0])
        Permutation([1, 2, 0])
        >>> Permutation([1, 0])*b
        Permutation([2, 0, 1])

        It is also acceptable to allow coercion to handle conversion of a
        single list to the left of a Permutation:

        >>> [0, 1]*a # no change: 2-element identity
        Permutation([1, 0, 2])
        >>> [[0, 1]]*a # exchange first two elements
        Permutation([0, 1, 2])

        You cannot use more than 1 cycle notation in a product of cycles
        since coercion can only handle one argument to the left. To handle
        multiple cycles it is convenient to use Cycle instead of Permutation:

        >>> [[1, 2]]*[[2, 3]]*Permutation([]) # doctest: +SKIP
        >>> from sympy.combinatorics.permutations import Cycle
        >>> Cycle(1, 2)(2, 3)
        (1 3 2)

        """"""
    a = self.array_form
    b = other.array_form
    if not b:
        perm = a
    else:
        b.extend(list(range(len(b), len(a))))
        perm = [b[i] for i in a] + b[len(a):]
    return _af_new(perm)","[{""var"": ""i"", ""rename"": ""index_position""}, {""var"": ""a"", ""rename"": ""self_permutation_array_form""}, {""var"": ""perm"", ""rename"": ""permutation_result""}, {""var"": ""b"", ""rename"": ""right_permutation_array_form""}]"
./sympy/combinatorics/permutations.py,commutes_with,check_permutation_commutativity,1305,1323,"def commutes_with(self, other):
    """"""
        Checks if the elements are commuting.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> a = Permutation([1, 4, 3, 0, 2, 5])
        >>> b = Permutation([0, 1, 2, 3, 4, 5])
        >>> a.commutes_with(b)
        True
        >>> b = Permutation([2, 3, 5, 4, 1, 0])
        >>> a.commutes_with(b)
        False
        """"""
    a = self.array_form
    b = other.array_form
    return _af_commutes_with(a, b)","def check_permutation_commutativity(self, other):
    """"""
        Checks if the elements are commuting.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> a = Permutation([1, 4, 3, 0, 2, 5])
        >>> b = Permutation([0, 1, 2, 3, 4, 5])
        >>> a.commutes_with(b)
        True
        >>> b = Permutation([2, 3, 5, 4, 1, 0])
        >>> a.commutes_with(b)
        False
        """"""
    a = self.array_form
    b = other.array_form
    return _af_commutes_with(a, b)","[{""var"": ""a"", ""rename"": ""self_array_form""}, {""var"": ""b"", ""rename"": ""other_permutation_array""}]"
./sympy/combinatorics/permutations.py,__pow__,find_permutation_power,1325,1344,"def __pow__(self, n):
    """"""
        Routine for finding powers of a permutation.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> p = Permutation([2,0,3,1])
        >>> p.order()
        4
        >>> p**4
        Permutation([0, 1, 2, 3])
        """"""
    if type(n) == Perm:
        raise NotImplementedError('p**p is not defined; do you mean p^p (conjugate)?')
    n = int(n)
    return _af_new(_af_pow(self.array_form, n))","def find_permutation_power(self, n):
    """"""
        Routine for finding powers of a permutation.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> p = Permutation([2,0,3,1])
        >>> p.order()
        4
        >>> p**4
        Permutation([0, 1, 2, 3])
        """"""
    if type(n) == Perm:
        raise NotImplementedError('p**p is not defined; do you mean p^p (conjugate)?')
    n = int(n)
    return _af_new(_af_pow(self.array_form, n))",[]
./sympy/combinatorics/permutations.py,__rxor__,apply_permutation_if_int,1346,1361,"def __rxor__(self, i):
    """"""Return self(i) when ``i`` is an int.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation
        >>> p = Permutation(1, 2, 9)
        >>> 2^p == p(2) == 9
        True
        """"""
    if int(i) == i:
        return self(i)
    else:
        raise NotImplementedError('i^p = p(i) when i is an integer, not %s.' % i)","def apply_permutation_if_int(self, i):
    """"""Return self(i) when ``i`` is an int.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation
        >>> p = Permutation(1, 2, 9)
        >>> 2^p == p(2) == 9
        True
        """"""
    if int(i) == i:
        return self(i)
    else:
        raise NotImplementedError('i^p = p(i) when i is an integer, not %s.' % i)",[]
./sympy/combinatorics/permutations.py,transpositions,decompose_into_transpositions,1441,1477,"def transpositions(self):
    """"""
        Return the permutation decomposed into a list of transpositions.

        It is always possible to express a permutation as the product of
        transpositions, see [1]

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation([[1, 2, 3], [0, 4, 5, 6, 7]])
        >>> t = p.transpositions()
        >>> t
        [(0, 7), (0, 6), (0, 5), (0, 4), (1, 3), (1, 2)]
        >>> print(''.join(str(c) for c in t))
        (0, 7)(0, 6)(0, 5)(0, 4)(1, 3)(1, 2)
        >>> Permutation.rmul(*[Permutation([ti], size=p.size) for ti in t]) == p
        True

        References
        ==========

        1. http://en.wikipedia.org/wiki/Transposition_%28mathematics%29#Properties

        """"""
    a = self.cyclic_form
    res = []
    for x in a:
        nx = len(x)
        if nx == 2:
            res.append(tuple(x))
        elif nx > 2:
            first = x[0]
            for y in x[nx - 1:0:-1]:
                res.append((first, y))
    return res","def decompose_into_transpositions(self):
    """"""
        Return the permutation decomposed into a list of transpositions.

        It is always possible to express a permutation as the product of
        transpositions, see [1]

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation([[1, 2, 3], [0, 4, 5, 6, 7]])
        >>> t = p.transpositions()
        >>> t
        [(0, 7), (0, 6), (0, 5), (0, 4), (1, 3), (1, 2)]
        >>> print(''.join(str(c) for c in t))
        (0, 7)(0, 6)(0, 5)(0, 4)(1, 3)(1, 2)
        >>> Permutation.rmul(*[Permutation([ti], size=p.size) for ti in t]) == p
        True

        References
        ==========

        1. http://en.wikipedia.org/wiki/Transposition_%28mathematics%29#Properties

        """"""
    a = self.cyclic_form
    res = []
    for x in a:
        nx = len(x)
        if nx == 2:
            res.append(tuple(x))
        elif nx > 2:
            first = x[0]
            for y in x[nx - 1:0:-1]:
                res.append((first, y))
    return res","[{""var"": ""y"", ""rename"": ""current_element""}, {""var"": ""a"", ""rename"": ""cyclic_permutation_form""}, {""var"": ""x"", ""rename"": ""cycle""}, {""var"": ""res"", ""rename"": ""transposition_list""}, {""var"": ""nx"", ""rename"": ""cycle_length""}, {""var"": ""first"", ""rename"": ""initial_element""}]"
./sympy/combinatorics/permutations.py,__iter__,yield_elements_from_array_form,1524,1535,"def __iter__(self):
    """"""Yield elements from array form.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation
        >>> list(Permutation(range(3)))
        [0, 1, 2]
        """"""
    for i in self.array_form:
        yield i","def yield_elements_from_array_form(self):
    """"""Yield elements from array form.

        Examples
        ========

        >>> from sympy.combinatorics import Permutation
        >>> list(Permutation(range(3)))
        [0, 1, 2]
        """"""
    for i in self.array_form:
        yield i","[{""var"": ""i"", ""rename"": ""element""}]"
./sympy/combinatorics/permutations.py,unrank_nonlex,generate_permutation_from_rank_nonlex,1635,1664,"@classmethod
def unrank_nonlex(self, n, r):
    """"""
        This is a linear time unranking algorithm that does not
        respect lexicographic order [3].

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> Permutation.unrank_nonlex(4, 5)
        Permutation([2, 0, 3, 1])
        >>> Permutation.unrank_nonlex(4, -1)
        Permutation([0, 1, 2, 3])

        See Also
        ========

        next_nonlex, rank_nonlex
        """"""

    def _unrank1(n, r, a):
        if n > 0:
            a[n - 1], a[r % n] = (a[r % n], a[n - 1])
            _unrank1(n - 1, r // n, a)
    id_perm = list(range(n))
    n = int(n)
    r = r % ifac(n)
    _unrank1(n, r, id_perm)
    return _af_new(id_perm)","@classmethod
def generate_permutation_from_rank_nonlex(self, n, r):
    """"""
        This is a linear time unranking algorithm that does not
        respect lexicographic order [3].

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> Permutation.unrank_nonlex(4, 5)
        Permutation([2, 0, 3, 1])
        >>> Permutation.unrank_nonlex(4, -1)
        Permutation([0, 1, 2, 3])

        See Also
        ========

        next_nonlex, rank_nonlex
        """"""

    def _unrank1(n, r, a):
        if n > 0:
            a[n - 1], a[r % n] = (a[r % n], a[n - 1])
            _unrank1(n - 1, r // n, a)
    id_perm = list(range(n))
    n = int(n)
    r = r % ifac(n)
    _unrank1(n, r, id_perm)
    return _af_new(id_perm)","[{""var"": ""id_perm"", ""rename"": ""initial_permutation_list""}]"
./sympy/combinatorics/permutations.py,rank_nonlex,linear_rank_nonlex_order,1666,1700,"def rank_nonlex(self, inv_perm=None):
    """"""
        This is a linear time ranking algorithm that does not
        enforce lexicographic order [3].


        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation([0, 1, 2, 3])
        >>> p.rank_nonlex()
        23

        See Also
        ========

        next_nonlex, unrank_nonlex
        """"""

    def _rank1(n, perm, inv_perm):
        if n == 1:
            return 0
        s = perm[n - 1]
        t = inv_perm[n - 1]
        perm[n - 1], perm[t] = (perm[t], s)
        inv_perm[n - 1], inv_perm[s] = (inv_perm[s], t)
        return s + n * _rank1(n - 1, perm, inv_perm)
    if inv_perm is None:
        inv_perm = (~self).array_form
    if not inv_perm:
        return 0
    perm = self.array_form[:]
    r = _rank1(len(perm), perm, inv_perm)
    return r","def linear_rank_nonlex_order(self, inv_perm=None):
    """"""
        This is a linear time ranking algorithm that does not
        enforce lexicographic order [3].


        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation([0, 1, 2, 3])
        >>> p.rank_nonlex()
        23

        See Also
        ========

        next_nonlex, unrank_nonlex
        """"""

    def _rank1(n, perm, inv_perm):
        if n == 1:
            return 0
        s = perm[n - 1]
        t = inv_perm[n - 1]
        perm[n - 1], perm[t] = (perm[t], s)
        inv_perm[n - 1], inv_perm[s] = (inv_perm[s], t)
        return s + n * _rank1(n - 1, perm, inv_perm)
    if inv_perm is None:
        inv_perm = (~self).array_form
    if not inv_perm:
        return 0
    perm = self.array_form[:]
    r = _rank1(len(perm), perm, inv_perm)
    return r","[{""var"": ""s"", ""rename"": ""current_permutation_value""}, {""var"": ""t"", ""rename"": ""target_index""}, {""var"": ""r"", ""rename"": ""non_lex_rank""}]"
./sympy/combinatorics/permutations.py,rank,calculate_lexicographic_permutation_rank,1729,1764,"def rank(self):
    """"""
        Returns the lexicographic rank of the permutation.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation([0, 1, 2, 3])
        >>> p.rank()
        0
        >>> p = Permutation([3, 2, 1, 0])
        >>> p.rank()
        23

        See Also
        ========

        next_lex, unrank_lex, cardinality, length, order, size
        """"""
    if not self._rank is None:
        return self._rank
    rank = 0
    rho = self.array_form[:]
    n = self.size - 1
    size = n + 1
    psize = int(ifac(n))
    for j in range(size - 1):
        rank += rho[j] * psize
        for i in range(j + 1, size):
            if rho[i] > rho[j]:
                rho[i] -= 1
        psize //= n
        n -= 1
    self._rank = rank
    return rank","def calculate_lexicographic_permutation_rank(self):
    """"""
        Returns the lexicographic rank of the permutation.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation([0, 1, 2, 3])
        >>> p.rank()
        0
        >>> p = Permutation([3, 2, 1, 0])
        >>> p.rank()
        23

        See Also
        ========

        next_lex, unrank_lex, cardinality, length, order, size
        """"""
    if not self._rank is None:
        return self._rank
    rank = 0
    rho = self.array_form[:]
    n = self.size - 1
    size = n + 1
    psize = int(ifac(n))
    for j in range(size - 1):
        rank += rho[j] * psize
        for i in range(j + 1, size):
            if rho[i] > rho[j]:
                rho[i] -= 1
        psize //= n
        n -= 1
    self._rank = rank
    return rank","[{""var"": ""n"", ""rename"": ""remaining_elements""}, {""var"": ""i"", ""rename"": ""decrement_index""}, {""var"": ""rho"", ""rename"": ""permutation_sequence""}, {""var"": ""j"", ""rename"": ""current_position""}, {""var"": ""psize"", ""rename"": ""factorial_divisor""}, {""var"": ""size"", ""rename"": ""permutation_size""}, {""var"": ""rank"", ""rename"": ""lexicographic_rank""}]"
./sympy/combinatorics/permutations.py,signature,permutation_signature_parity,2130,2159,"def signature(self):
    """"""
        Gives the signature of the permutation needed to place the
        elements of the permutation in canonical order.

        The signature is calculated as (-1)^<number of inversions>

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation([0, 1, 2])
        >>> p.inversions()
        0
        >>> p.signature()
        1
        >>> q = Permutation([0,2,1])
        >>> q.inversions()
        1
        >>> q.signature()
        -1

        See Also
        ========

        inversions
        """"""
    if self.is_even:
        return 1
    return -1","def permutation_signature_parity(self):
    """"""
        Gives the signature of the permutation needed to place the
        elements of the permutation in canonical order.

        The signature is calculated as (-1)^<number of inversions>

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation([0, 1, 2])
        >>> p.inversions()
        0
        >>> p.signature()
        1
        >>> q = Permutation([0,2,1])
        >>> q.inversions()
        1
        >>> q.signature()
        -1

        See Also
        ========

        inversions
        """"""
    if self.is_even:
        return 1
    return -1",[]
./sympy/combinatorics/permutations.py,unrank_trotterjohnson,generate_permutation_from_rank_trotterjohnson,2393,2426,"@classmethod
def unrank_trotterjohnson(self, size, rank):
    """"""
        Trotter Johnson permutation unranking. See [4] section 2.4.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.unrank_trotterjohnson(5, 10)
        Permutation([0, 3, 1, 2, 4])

        See Also
        ========

        rank_trotterjohnson, next_trotterjohnson
        """"""
    perm = [0] * size
    r2 = 0
    n = ifac(size)
    pj = 1
    for j in range(2, size + 1):
        pj *= j
        r1 = rank * pj // n
        k = r1 - j * r2
        if r2 % 2 == 0:
            for i in range(j - 1, j - k - 1, -1):
                perm[i] = perm[i - 1]
            perm[j - k - 1] = j - 1
        else:
            for i in range(j - 1, k, -1):
                perm[i] = perm[i - 1]
            perm[k] = j - 1
        r2 = r1
    return _af_new(perm)","@classmethod
def generate_permutation_from_rank_trotterjohnson(self, size, rank):
    """"""
        Trotter Johnson permutation unranking. See [4] section 2.4.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.unrank_trotterjohnson(5, 10)
        Permutation([0, 3, 1, 2, 4])

        See Also
        ========

        rank_trotterjohnson, next_trotterjohnson
        """"""
    perm = [0] * size
    r2 = 0
    n = ifac(size)
    pj = 1
    for j in range(2, size + 1):
        pj *= j
        r1 = rank * pj // n
        k = r1 - j * r2
        if r2 % 2 == 0:
            for i in range(j - 1, j - k - 1, -1):
                perm[i] = perm[i - 1]
            perm[j - k - 1] = j - 1
        else:
            for i in range(j - 1, k, -1):
                perm[i] = perm[i - 1]
            perm[k] = j - 1
        r2 = r1
    return _af_new(perm)","[{""var"": ""perm"", ""rename"": ""trotterjohnson_permutation""}, {""var"": ""k"", ""rename"": ""current_increment""}, {""var"": ""n"", ""rename"": ""factorial_size""}, {""var"": ""i"", ""rename"": ""current_index""}, {""var"": ""pj"", ""rename"": ""factorial_product""}, {""var"": ""j"", ""rename"": ""current_permutation_length""}, {""var"": ""r2"", ""rename"": ""previous_rank""}, {""var"": ""r1"", ""rename"": ""cumulative_rank""}]"
./sympy/combinatorics/permutations.py,next_trotterjohnson,next_permutation_trotter_johnson_order,2428,2480,"def next_trotterjohnson(self):
    """"""
        Returns the next permutation in Trotter-Johnson order.
        If self is the last permutation it returns None.
        See [4] section 2.4. If it is desired to generate all such
        permutations, they can be generated in order more quickly
        with the ``generate_bell`` function.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> p = Permutation([3, 0, 2, 1])
        >>> p.rank_trotterjohnson()
        4
        >>> p = p.next_trotterjohnson(); p
        Permutation([0, 3, 2, 1])
        >>> p.rank_trotterjohnson()
        5

        See Also
        ========

        rank_trotterjohnson, unrank_trotterjohnson, sympy.utilities.iterables.generate_bell
        """"""
    pi = self.array_form[:]
    n = len(pi)
    st = 0
    rho = pi[:]
    done = False
    m = n - 1
    while m > 0 and (not done):
        d = rho.index(m)
        for i in range(d, m):
            rho[i] = rho[i + 1]
        par = _af_parity(rho[:m])
        if par == 1:
            if d == m:
                m -= 1
            else:
                pi[st + d], pi[st + d + 1] = (pi[st + d + 1], pi[st + d])
                done = True
        elif d == 0:
            m -= 1
            st += 1
        else:
            pi[st + d], pi[st + d - 1] = (pi[st + d - 1], pi[st + d])
            done = True
    if m == 0:
        return None
    return _af_new(pi)","def next_permutation_trotter_johnson_order(self):
    """"""
        Returns the next permutation in Trotter-Johnson order.
        If self is the last permutation it returns None.
        See [4] section 2.4. If it is desired to generate all such
        permutations, they can be generated in order more quickly
        with the ``generate_bell`` function.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> p = Permutation([3, 0, 2, 1])
        >>> p.rank_trotterjohnson()
        4
        >>> p = p.next_trotterjohnson(); p
        Permutation([0, 3, 2, 1])
        >>> p.rank_trotterjohnson()
        5

        See Also
        ========

        rank_trotterjohnson, unrank_trotterjohnson, sympy.utilities.iterables.generate_bell
        """"""
    pi = self.array_form[:]
    n = len(pi)
    st = 0
    rho = pi[:]
    done = False
    m = n - 1
    while m > 0 and (not done):
        d = rho.index(m)
        for i in range(d, m):
            rho[i] = rho[i + 1]
        par = _af_parity(rho[:m])
        if par == 1:
            if d == m:
                m -= 1
            else:
                pi[st + d], pi[st + d + 1] = (pi[st + d + 1], pi[st + d])
                done = True
        elif d == 0:
            m -= 1
            st += 1
        else:
            pi[st + d], pi[st + d - 1] = (pi[st + d - 1], pi[st + d])
            done = True
    if m == 0:
        return None
    return _af_new(pi)","[{""var"": ""st"", ""rename"": ""current_segment_start""}, {""var"": ""n"", ""rename"": ""permutation_length""}, {""var"": ""i"", ""rename"": ""currentPositionIndex""}, {""var"": ""rho"", ""rename"": ""working_permutation""}, {""var"": ""par"", ""rename"": ""permutation_parity""}, {""var"": ""m"", ""rename"": ""current_element_index""}, {""var"": ""pi"", ""rename"": ""current_permutation_array""}, {""var"": ""done"", ""rename"": ""permutation_found""}, {""var"": ""d"", ""rename"": ""current_position""}]"
./sympy/combinatorics/permutations.py,get_precedence_matrix,compute_permutation_precedence_matrix,2482,2513,"def get_precedence_matrix(self):
    """"""
        Gets the precedence matrix. This is used for computing the
        distance between two permutations.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation.josephus(3, 6, 1)
        >>> p
        Permutation([2, 5, 3, 1, 4, 0])
        >>> p.get_precedence_matrix()
        Matrix([
        [0, 0, 0, 0, 0, 0],
        [1, 0, 0, 0, 1, 0],
        [1, 1, 0, 1, 1, 1],
        [1, 1, 0, 0, 1, 0],
        [1, 0, 0, 0, 0, 0],
        [1, 1, 0, 1, 1, 0]])

        See Also
        ========

        get_precedence_distance, get_adjacency_matrix, get_adjacency_distance
        """"""
    m = zeros(self.size)
    perm = self.array_form
    for i in range(m.rows):
        for j in range(i + 1, m.cols):
            m[perm[i], perm[j]] = 1
    return m","def compute_permutation_precedence_matrix(self):
    """"""
        Gets the precedence matrix. This is used for computing the
        distance between two permutations.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> p = Permutation.josephus(3, 6, 1)
        >>> p
        Permutation([2, 5, 3, 1, 4, 0])
        >>> p.get_precedence_matrix()
        Matrix([
        [0, 0, 0, 0, 0, 0],
        [1, 0, 0, 0, 1, 0],
        [1, 1, 0, 1, 1, 1],
        [1, 1, 0, 0, 1, 0],
        [1, 0, 0, 0, 0, 0],
        [1, 1, 0, 1, 1, 0]])

        See Also
        ========

        get_precedence_distance, get_adjacency_matrix, get_adjacency_distance
        """"""
    m = zeros(self.size)
    perm = self.array_form
    for i in range(m.rows):
        for j in range(i + 1, m.cols):
            m[perm[i], perm[j]] = 1
    return m","[{""var"": ""i"", ""rename"": ""first_index""}, {""var"": ""perm"", ""rename"": ""permutation_order""}, {""var"": ""j"", ""rename"": ""column_index""}, {""var"": ""m"", ""rename"": ""python\nprecedence_matrix""}]"
./sympy/combinatorics/permutations.py,josephus,josephus_permutation_sequence,2664,2710,"@classmethod
def josephus(self, m, n, s=1):
    """"""Return as a permutation the shuffling of range(n) using the Josephus
        scheme in which every m-th item is selected until all have been chosen.
        The returned permutation has elements listed by the order in which they
        were selected.

        The parameter ``s`` stops the selection process when there are ``s``
        items remaining and these are selected by continuing the selection,
        counting by 1 rather than by ``m``.

        Consider selecting every 3rd item from 6 until only 2 remain::

            choices    chosen
            ========   ======
              012345
              01 345   2
              01 34    25
              01  4    253
              0   4    2531
              0        25314
                       253140

        Examples
        ========

        >>> from sympy.combinatorics import Permutation
        >>> Permutation.josephus(3, 6, 2).array_form
        [2, 5, 3, 1, 4, 0]

        References
        ==========

        1. http://en.wikipedia.org/wiki/Flavius_Josephus
        2. http://en.wikipedia.org/wiki/Josephus_problem
        3. http://www.wou.edu/~burtonl/josephus.html

        """"""
    from collections import deque
    m -= 1
    Q = deque(list(range(n)))
    perm = []
    while len(Q) > max(s, 1):
        for dp in range(m):
            Q.append(Q.popleft())
        perm.append(Q.popleft())
    perm.extend(list(Q))
    return Perm(perm)","@classmethod
def josephus_permutation_sequence(self, m, n, s=1):
    """"""Return as a permutation the shuffling of range(n) using the Josephus
        scheme in which every m-th item is selected until all have been chosen.
        The returned permutation has elements listed by the order in which they
        were selected.

        The parameter ``s`` stops the selection process when there are ``s``
        items remaining and these are selected by continuing the selection,
        counting by 1 rather than by ``m``.

        Consider selecting every 3rd item from 6 until only 2 remain::

            choices    chosen
            ========   ======
              012345
              01 345   2
              01 34    25
              01  4    253
              0   4    2531
              0        25314
                       253140

        Examples
        ========

        >>> from sympy.combinatorics import Permutation
        >>> Permutation.josephus(3, 6, 2).array_form
        [2, 5, 3, 1, 4, 0]

        References
        ==========

        1. http://en.wikipedia.org/wiki/Flavius_Josephus
        2. http://en.wikipedia.org/wiki/Josephus_problem
        3. http://www.wou.edu/~burtonl/josephus.html

        """"""
    from collections import deque
    m -= 1
    Q = deque(list(range(n)))
    perm = []
    while len(Q) > max(s, 1):
        for dp in range(m):
            Q.append(Q.popleft())
        perm.append(Q.popleft())
    perm.extend(list(Q))
    return Perm(perm)","[{""var"": ""Q"", ""rename"": ""selection_queue""}, {""var"": ""dp"", ""rename"": ""rotation_count""}, {""var"": ""perm"", ""rename"": ""josephus_selection_order""}]"
./sympy/combinatorics/permutations.py,from_inversion_vector,calculate_permutation_from_inversion_vector,2713,2737,"@classmethod
def from_inversion_vector(self, inversion):
    """"""
        Calculates the permutation from the inversion vector.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> Permutation.from_inversion_vector([3, 2, 1, 0, 0])
        Permutation([3, 2, 1, 0, 4, 5])

        """"""
    size = len(inversion)
    N = list(range(size + 1))
    perm = []
    try:
        for k in range(size):
            val = N[inversion[k]]
            perm.append(val)
            N.remove(val)
    except IndexError:
        raise ValueError('The inversion vector is not valid.')
    perm.extend(N)
    return _af_new(perm)","@classmethod
def calculate_permutation_from_inversion_vector(self, inversion):
    """"""
        Calculates the permutation from the inversion vector.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> Permutation.from_inversion_vector([3, 2, 1, 0, 0])
        Permutation([3, 2, 1, 0, 4, 5])

        """"""
    size = len(inversion)
    N = list(range(size + 1))
    perm = []
    try:
        for k in range(size):
            val = N[inversion[k]]
            perm.append(val)
            N.remove(val)
    except IndexError:
        raise ValueError('The inversion vector is not valid.')
    perm.extend(N)
    return _af_new(perm)","[{""var"": ""val"", ""rename"": ""selected_value""}, {""var"": ""perm"", ""rename"": ""calculated_permutation""}, {""var"": ""k"", ""rename"": ""current_index""}, {""var"": ""size"", ""rename"": ""inversion_length""}, {""var"": ""N"", ""rename"": ""available_positions""}]"
./sympy/combinatorics/permutations.py,random,generate_random_permutation,2740,2756,"@classmethod
def random(self, n):
    """"""
        Generates a random permutation of length ``n``.

        Uses the underlying Python pseudo-random number generator.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.random(2) in (Permutation([1, 0]), Permutation([0, 1]))
        True

        """"""
    perm_array = list(range(n))
    random.shuffle(perm_array)
    return _af_new(perm_array)","@classmethod
def generate_random_permutation(self, n):
    """"""
        Generates a random permutation of length ``n``.

        Uses the underlying Python pseudo-random number generator.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.random(2) in (Permutation([1, 0]), Permutation([0, 1]))
        True

        """"""
    perm_array = list(range(n))
    random.shuffle(perm_array)
    return _af_new(perm_array)","[{""var"": ""perm_array"", ""rename"": ""randomized_permutation_list""}]"
./sympy/combinatorics/permutations.py,unrank_lex,lexicographic_permutation_from_rank,2759,2790,"@classmethod
def unrank_lex(self, size, rank):
    """"""
        Lexicographic permutation unranking.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> a = Permutation.unrank_lex(5, 10)
        >>> a.rank()
        10
        >>> a
        Permutation([0, 2, 4, 1, 3])

        See Also
        ========

        rank, next_lex
        """"""
    perm_array = [0] * size
    psize = 1
    for i in range(size):
        new_psize = psize * (i + 1)
        d = rank % new_psize // psize
        rank -= d * psize
        perm_array[size - i - 1] = d
        for j in range(size - i, size):
            if perm_array[j] > d - 1:
                perm_array[j] += 1
        psize = new_psize
    return _af_new(perm_array)","@classmethod
def lexicographic_permutation_from_rank(self, size, rank):
    """"""
        Lexicographic permutation unranking.

        Examples
        ========

        >>> from sympy.combinatorics.permutations import Permutation
        >>> Permutation.print_cyclic = False
        >>> a = Permutation.unrank_lex(5, 10)
        >>> a.rank()
        10
        >>> a
        Permutation([0, 2, 4, 1, 3])

        See Also
        ========

        rank, next_lex
        """"""
    perm_array = [0] * size
    psize = 1
    for i in range(size):
        new_psize = psize * (i + 1)
        d = rank % new_psize // psize
        rank -= d * psize
        perm_array[size - i - 1] = d
        for j in range(size - i, size):
            if perm_array[j] > d - 1:
                perm_array[j] += 1
        psize = new_psize
    return _af_new(perm_array)","[{""var"": ""perm_array"", ""rename"": ""lexicographic_rank_array""}, {""var"": ""i"", ""rename"": ""current_index""}, {""var"": ""new_psize"", ""rename"": ""updated_permutation_factorial""}, {""var"": ""j"", ""rename"": ""index""}, {""var"": ""psize"", ""rename"": ""current_factorial_size""}, {""var"": ""d"", ""rename"": ""current_digit""}]"
