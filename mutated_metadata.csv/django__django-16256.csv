file,method_name,new_method_name,start_line,end_line,original_code,code,var
./django/contrib/contenttypes/fields.py,create_generic_related_manager,generate_generic_relation_manager,557,766,"def create_generic_related_manager(superclass, rel):
    """"""
    Factory function to create a manager that subclasses another manager
    (generally the default manager of a given model) and adds behaviors
    specific to generic relations.
    """"""

    class GenericRelatedObjectManager(superclass, AltersData):

        def __init__(self, instance=None):
            super().__init__()
            self.instance = instance
            self.model = rel.model
            self.get_content_type = functools.partial(ContentType.objects.db_manager(instance._state.db).get_for_model, for_concrete_model=rel.field.for_concrete_model)
            self.content_type = self.get_content_type(instance)
            self.content_type_field_name = rel.field.content_type_field_name
            self.object_id_field_name = rel.field.object_id_field_name
            self.prefetch_cache_name = rel.field.attname
            self.pk_val = instance.pk
            self.core_filters = {'%s__pk' % self.content_type_field_name: self.content_type.id, self.object_id_field_name: self.pk_val}

        def __call__(self, *, manager):
            manager = getattr(self.model, manager)
            manager_class = create_generic_related_manager(manager.__class__, rel)
            return manager_class(instance=self.instance)
        do_not_call_in_templates = True

        def __str__(self):
            return repr(self)

        def _apply_rel_filters(self, queryset):
            """"""
            Filter the queryset for the instance this manager is bound to.
            """"""
            db = self._db or router.db_for_read(self.model, instance=self.instance)
            return queryset.using(db).filter(**self.core_filters)

        def _remove_prefetched_objects(self):
            try:
                self.instance._prefetched_objects_cache.pop(self.prefetch_cache_name)
            except (AttributeError, KeyError):
                pass

        def get_queryset(self):
            try:
                return self.instance._prefetched_objects_cache[self.prefetch_cache_name]
            except (AttributeError, KeyError):
                queryset = super().get_queryset()
                return self._apply_rel_filters(queryset)

        def get_prefetch_queryset(self, instances, queryset=None):
            if queryset is None:
                queryset = super().get_queryset()
            queryset._add_hints(instance=instances[0])
            queryset = queryset.using(queryset._db or self._db)
            content_type_queries = [models.Q.create([(f'{self.content_type_field_name}__pk', content_type_id), (f'{self.object_id_field_name}__in', {obj.pk for obj in objs})]) for content_type_id, objs in itertools.groupby(sorted(instances, key=lambda obj: self.get_content_type(obj).pk), lambda obj: self.get_content_type(obj).pk)]
            query = models.Q.create(content_type_queries, connector=models.Q.OR)
            object_id_converter = instances[0]._meta.pk.to_python
            content_type_id_field_name = '%s_id' % self.content_type_field_name
            return (queryset.filter(query), lambda relobj: (object_id_converter(getattr(relobj, self.object_id_field_name)), getattr(relobj, content_type_id_field_name)), lambda obj: (obj.pk, self.get_content_type(obj).pk), False, self.prefetch_cache_name, False)

        def add(self, *objs, bulk=True):
            self._remove_prefetched_objects()
            db = router.db_for_write(self.model, instance=self.instance)

            def check_and_update_obj(obj):
                if not isinstance(obj, self.model):
                    raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
                setattr(obj, self.content_type_field_name, self.content_type)
                setattr(obj, self.object_id_field_name, self.pk_val)
            if bulk:
                pks = []
                for obj in objs:
                    if obj._state.adding or obj._state.db != db:
                        raise ValueError(""%r instance isn't saved. Use bulk=False or save the object first."" % obj)
                    check_and_update_obj(obj)
                    pks.append(obj.pk)
                self.model._base_manager.using(db).filter(pk__in=pks).update(**{self.content_type_field_name: self.content_type, self.object_id_field_name: self.pk_val})
            else:
                with transaction.atomic(using=db, savepoint=False):
                    for obj in objs:
                        check_and_update_obj(obj)
                        obj.save()
        add.alters_data = True

        def remove(self, *objs, bulk=True):
            if not objs:
                return
            self._clear(self.filter(pk__in=[o.pk for o in objs]), bulk)
        remove.alters_data = True

        def clear(self, *, bulk=True):
            self._clear(self, bulk)
        clear.alters_data = True

        def _clear(self, queryset, bulk):
            self._remove_prefetched_objects()
            db = router.db_for_write(self.model, instance=self.instance)
            queryset = queryset.using(db)
            if bulk:
                queryset.delete()
            else:
                with transaction.atomic(using=db, savepoint=False):
                    for obj in queryset:
                        obj.delete()
        _clear.alters_data = True

        def set(self, objs, *, bulk=True, clear=False):
            objs = tuple(objs)
            db = router.db_for_write(self.model, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                if clear:
                    self.clear()
                    self.add(*objs, bulk=bulk)
                else:
                    old_objs = set(self.using(db).all())
                    new_objs = []
                    for obj in objs:
                        if obj in old_objs:
                            old_objs.remove(obj)
                        else:
                            new_objs.append(obj)
                    self.remove(*old_objs)
                    self.add(*new_objs, bulk=bulk)
        set.alters_data = True

        def create(self, **kwargs):
            self._remove_prefetched_objects()
            kwargs[self.content_type_field_name] = self.content_type
            kwargs[self.object_id_field_name] = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance)
            return super().using(db).create(**kwargs)
        create.alters_data = True

        def get_or_create(self, **kwargs):
            kwargs[self.content_type_field_name] = self.content_type
            kwargs[self.object_id_field_name] = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance)
            return super().using(db).get_or_create(**kwargs)
        get_or_create.alters_data = True

        def update_or_create(self, **kwargs):
            kwargs[self.content_type_field_name] = self.content_type
            kwargs[self.object_id_field_name] = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance)
            return super().using(db).update_or_create(**kwargs)
        update_or_create.alters_data = True
    return GenericRelatedObjectManager","def generate_generic_relation_manager(superclass, rel):
    """"""
    Factory function to create a manager that subclasses another manager
    (generally the default manager of a given model) and adds behaviors
    specific to generic relations.
    """"""

    class GenericRelatedObjectManager(superclass, AltersData):

        def __init__(self, instance=None):
            super().__init__()
            self.instance = instance
            self.model = rel.model
            self.get_content_type = functools.partial(ContentType.objects.db_manager(instance._state.db).get_for_model, for_concrete_model=rel.field.for_concrete_model)
            self.content_type = self.get_content_type(instance)
            self.content_type_field_name = rel.field.content_type_field_name
            self.object_id_field_name = rel.field.object_id_field_name
            self.prefetch_cache_name = rel.field.attname
            self.pk_val = instance.pk
            self.core_filters = {'%s__pk' % self.content_type_field_name: self.content_type.id, self.object_id_field_name: self.pk_val}

        def __call__(self, *, manager):
            manager = getattr(self.model, manager)
            manager_class = create_generic_related_manager(manager.__class__, rel)
            return manager_class(instance=self.instance)
        do_not_call_in_templates = True

        def __str__(self):
            return repr(self)

        def _apply_rel_filters(self, queryset):
            """"""
            Filter the queryset for the instance this manager is bound to.
            """"""
            db = self._db or router.db_for_read(self.model, instance=self.instance)
            return queryset.using(db).filter(**self.core_filters)

        def _remove_prefetched_objects(self):
            try:
                self.instance._prefetched_objects_cache.pop(self.prefetch_cache_name)
            except (AttributeError, KeyError):
                pass

        def get_queryset(self):
            try:
                return self.instance._prefetched_objects_cache[self.prefetch_cache_name]
            except (AttributeError, KeyError):
                queryset = super().get_queryset()
                return self._apply_rel_filters(queryset)

        def get_prefetch_queryset(self, instances, queryset=None):
            if queryset is None:
                queryset = super().get_queryset()
            queryset._add_hints(instance=instances[0])
            queryset = queryset.using(queryset._db or self._db)
            content_type_queries = [models.Q.create([(f'{self.content_type_field_name}__pk', content_type_id), (f'{self.object_id_field_name}__in', {obj.pk for obj in objs})]) for content_type_id, objs in itertools.groupby(sorted(instances, key=lambda obj: self.get_content_type(obj).pk), lambda obj: self.get_content_type(obj).pk)]
            query = models.Q.create(content_type_queries, connector=models.Q.OR)
            object_id_converter = instances[0]._meta.pk.to_python
            content_type_id_field_name = '%s_id' % self.content_type_field_name
            return (queryset.filter(query), lambda relobj: (object_id_converter(getattr(relobj, self.object_id_field_name)), getattr(relobj, content_type_id_field_name)), lambda obj: (obj.pk, self.get_content_type(obj).pk), False, self.prefetch_cache_name, False)

        def add(self, *objs, bulk=True):
            self._remove_prefetched_objects()
            db = router.db_for_write(self.model, instance=self.instance)

            def check_and_update_obj(obj):
                if not isinstance(obj, self.model):
                    raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
                setattr(obj, self.content_type_field_name, self.content_type)
                setattr(obj, self.object_id_field_name, self.pk_val)
            if bulk:
                pks = []
                for obj in objs:
                    if obj._state.adding or obj._state.db != db:
                        raise ValueError(""%r instance isn't saved. Use bulk=False or save the object first."" % obj)
                    check_and_update_obj(obj)
                    pks.append(obj.pk)
                self.model._base_manager.using(db).filter(pk__in=pks).update(**{self.content_type_field_name: self.content_type, self.object_id_field_name: self.pk_val})
            else:
                with transaction.atomic(using=db, savepoint=False):
                    for obj in objs:
                        check_and_update_obj(obj)
                        obj.save()
        add.alters_data = True

        def remove(self, *objs, bulk=True):
            if not objs:
                return
            self._clear(self.filter(pk__in=[o.pk for o in objs]), bulk)
        remove.alters_data = True

        def clear(self, *, bulk=True):
            self._clear(self, bulk)
        clear.alters_data = True

        def _clear(self, queryset, bulk):
            self._remove_prefetched_objects()
            db = router.db_for_write(self.model, instance=self.instance)
            queryset = queryset.using(db)
            if bulk:
                queryset.delete()
            else:
                with transaction.atomic(using=db, savepoint=False):
                    for obj in queryset:
                        obj.delete()
        _clear.alters_data = True

        def set(self, objs, *, bulk=True, clear=False):
            objs = tuple(objs)
            db = router.db_for_write(self.model, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                if clear:
                    self.clear()
                    self.add(*objs, bulk=bulk)
                else:
                    old_objs = set(self.using(db).all())
                    new_objs = []
                    for obj in objs:
                        if obj in old_objs:
                            old_objs.remove(obj)
                        else:
                            new_objs.append(obj)
                    self.remove(*old_objs)
                    self.add(*new_objs, bulk=bulk)
        set.alters_data = True

        def create(self, **kwargs):
            self._remove_prefetched_objects()
            kwargs[self.content_type_field_name] = self.content_type
            kwargs[self.object_id_field_name] = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance)
            return super().using(db).create(**kwargs)
        create.alters_data = True

        def get_or_create(self, **kwargs):
            kwargs[self.content_type_field_name] = self.content_type
            kwargs[self.object_id_field_name] = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance)
            return super().using(db).get_or_create(**kwargs)
        get_or_create.alters_data = True

        def update_or_create(self, **kwargs):
            kwargs[self.content_type_field_name] = self.content_type
            kwargs[self.object_id_field_name] = self.pk_val
            db = router.db_for_write(self.model, instance=self.instance)
            return super().using(db).update_or_create(**kwargs)
        update_or_create.alters_data = True
    return GenericRelatedObjectManager","[{""var"": ""new_objs"", ""rename"": ""pending_related_objects""}, {""var"": ""query"", ""rename"": ""related_content_type_query""}, {""var"": ""do_not_call_in_templates"", ""rename"": ""template_incompatibility_flag""}, {""var"": ""pks"", ""rename"": ""primary_keys""}, {""var"": ""o"", ""rename"": ""generic_related_manager_factory""}, {""var"": ""content_type_queries"", ""rename"": ""generic_relation_filters""}, {""var"": ""obj"", ""rename"": ""generic_related_instance""}, {""var"": ""object_id_converter"", ""rename"": ""object_id_parser_function""}, {""var"": ""objs"", ""rename"": ""related_objects""}, {""var"": ""db"", ""rename"": ""database_identifier""}, {""var"": ""old_objs"", ""rename"": ""existing_related_objects""}, {""var"": ""content_type_id_field_name"", ""rename"": ""generic_relation_content_type_field""}, {""var"": ""manager_class"", ""rename"": ""GenericRelationManagerSubclass""}, {""var"": ""content_type_id"", ""rename"": ""related_content_type_identifier""}]"
./django/contrib/contenttypes/fields.py,get_or_create,fetch_or_initialize_instance_representation,750,754,"def get_or_create(self, **kwargs):
    kwargs[self.content_type_field_name] = self.content_type
    kwargs[self.object_id_field_name] = self.pk_val
    db = router.db_for_write(self.model, instance=self.instance)
    return super().using(db).get_or_create(**kwargs)","def fetch_or_initialize_instance_representation(self, **kwargs):
    kwargs[self.content_type_field_name] = self.content_type
    kwargs[self.object_id_field_name] = self.pk_val
    db = router.db_for_write(self.model, instance=self.instance)
    return super().using(db).get_or_create(**kwargs)","[{""var"": ""db"", ""rename"": ""database_write_target""}]"
./django/db/models/fields/related_descriptors.py,create_reverse_many_to_one_manager,create_related_manager_for_reverse_m2o,630,891,"def create_reverse_many_to_one_manager(superclass, rel):
    """"""
    Create a manager for the reverse side of a many-to-one relation.

    This manager subclasses another manager, generally the default manager of
    the related model, and adds behaviors specific to many-to-one relations.
    """"""

    class RelatedManager(superclass, AltersData):

        def __init__(self, instance):
            super().__init__()
            self.instance = instance
            self.model = rel.related_model
            self.field = rel.field
            self.core_filters = {self.field.name: instance}

        def __call__(self, *, manager):
            manager = getattr(self.model, manager)
            manager_class = create_reverse_many_to_one_manager(manager.__class__, rel)
            return manager_class(self.instance)
        do_not_call_in_templates = True

        def _check_fk_val(self):
            for field in self.field.foreign_related_fields:
                if getattr(self.instance, field.attname) is None:
                    raise ValueError(f'""{self.instance!r}"" needs to have a value for field ""{field.attname}"" before this relationship can be used.')

        def _apply_rel_filters(self, queryset):
            """"""
            Filter the queryset for the instance this manager is bound to.
            """"""
            db = self._db or router.db_for_read(self.model, instance=self.instance)
            empty_strings_as_null = connections[db].features.interprets_empty_strings_as_nulls
            queryset._add_hints(instance=self.instance)
            if self._db:
                queryset = queryset.using(self._db)
            queryset._defer_next_filter = True
            queryset = queryset.filter(**self.core_filters)
            for field in self.field.foreign_related_fields:
                val = getattr(self.instance, field.attname)
                if val is None or (val == '' and empty_strings_as_null):
                    return queryset.none()
            if self.field.many_to_one:
                try:
                    target_field = self.field.target_field
                except FieldError:
                    rel_obj_id = tuple([getattr(self.instance, target_field.attname) for target_field in self.field.path_infos[-1].target_fields])
                else:
                    rel_obj_id = getattr(self.instance, target_field.attname)
                queryset._known_related_objects = {self.field: {rel_obj_id: self.instance}}
            return queryset

        def _remove_prefetched_objects(self):
            try:
                self.instance._prefetched_objects_cache.pop(self.field.remote_field.get_cache_name())
            except (AttributeError, KeyError):
                pass

        def get_queryset(self):
            if self.instance.pk is None:
                raise ValueError(f'{self.instance.__class__.__name__!r} instance needs to have a primary key value before this relationship can be used.')
            try:
                return self.instance._prefetched_objects_cache[self.field.remote_field.get_cache_name()]
            except (AttributeError, KeyError):
                queryset = super().get_queryset()
                return self._apply_rel_filters(queryset)

        def get_prefetch_queryset(self, instances, queryset=None):
            if queryset is None:
                queryset = super().get_queryset()
            queryset._add_hints(instance=instances[0])
            queryset = queryset.using(queryset._db or self._db)
            rel_obj_attr = self.field.get_local_related_value
            instance_attr = self.field.get_foreign_related_value
            instances_dict = {instance_attr(inst): inst for inst in instances}
            queryset = _filter_prefetch_queryset(queryset, self.field.name, instances)
            for rel_obj in queryset:
                if not self.field.is_cached(rel_obj):
                    instance = instances_dict[rel_obj_attr(rel_obj)]
                    setattr(rel_obj, self.field.name, instance)
            cache_name = self.field.remote_field.get_cache_name()
            return (queryset, rel_obj_attr, instance_attr, False, cache_name, False)

        def add(self, *objs, bulk=True):
            self._check_fk_val()
            self._remove_prefetched_objects()
            db = router.db_for_write(self.model, instance=self.instance)

            def check_and_update_obj(obj):
                if not isinstance(obj, self.model):
                    raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
                setattr(obj, self.field.name, self.instance)
            if bulk:
                pks = []
                for obj in objs:
                    check_and_update_obj(obj)
                    if obj._state.adding or obj._state.db != db:
                        raise ValueError(""%r instance isn't saved. Use bulk=False or save the object first."" % obj)
                    pks.append(obj.pk)
                self.model._base_manager.using(db).filter(pk__in=pks).update(**{self.field.name: self.instance})
            else:
                with transaction.atomic(using=db, savepoint=False):
                    for obj in objs:
                        check_and_update_obj(obj)
                        obj.save()
        add.alters_data = True

        def create(self, **kwargs):
            self._check_fk_val()
            kwargs[self.field.name] = self.instance
            db = router.db_for_write(self.model, instance=self.instance)
            return super(RelatedManager, self.db_manager(db)).create(**kwargs)
        create.alters_data = True

        def get_or_create(self, **kwargs):
            self._check_fk_val()
            kwargs[self.field.name] = self.instance
            db = router.db_for_write(self.model, instance=self.instance)
            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)
        get_or_create.alters_data = True

        def update_or_create(self, **kwargs):
            self._check_fk_val()
            kwargs[self.field.name] = self.instance
            db = router.db_for_write(self.model, instance=self.instance)
            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)
        update_or_create.alters_data = True
        if rel.field.null:

            def remove(self, *objs, bulk=True):
                if not objs:
                    return
                self._check_fk_val()
                val = self.field.get_foreign_related_value(self.instance)
                old_ids = set()
                for obj in objs:
                    if not isinstance(obj, self.model):
                        raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
                    if self.field.get_local_related_value(obj) == val:
                        old_ids.add(obj.pk)
                    else:
                        raise self.field.remote_field.model.DoesNotExist('%r is not related to %r.' % (obj, self.instance))
                self._clear(self.filter(pk__in=old_ids), bulk)
            remove.alters_data = True

            def clear(self, *, bulk=True):
                self._check_fk_val()
                self._clear(self, bulk)
            clear.alters_data = True

            def _clear(self, queryset, bulk):
                self._remove_prefetched_objects()
                db = router.db_for_write(self.model, instance=self.instance)
                queryset = queryset.using(db)
                if bulk:
                    queryset.update(**{self.field.name: None})
                else:
                    with transaction.atomic(using=db, savepoint=False):
                        for obj in queryset:
                            setattr(obj, self.field.name, None)
                            obj.save(update_fields=[self.field.name])
            _clear.alters_data = True

        def set(self, objs, *, bulk=True, clear=False):
            self._check_fk_val()
            objs = tuple(objs)
            if self.field.null:
                db = router.db_for_write(self.model, instance=self.instance)
                with transaction.atomic(using=db, savepoint=False):
                    if clear:
                        self.clear(bulk=bulk)
                        self.add(*objs, bulk=bulk)
                    else:
                        old_objs = set(self.using(db).all())
                        new_objs = []
                        for obj in objs:
                            if obj in old_objs:
                                old_objs.remove(obj)
                            else:
                                new_objs.append(obj)
                        self.remove(*old_objs, bulk=bulk)
                        self.add(*new_objs, bulk=bulk)
            else:
                self.add(*objs, bulk=bulk)
        set.alters_data = True
    return RelatedManager","def create_related_manager_for_reverse_m2o(superclass, rel):
    """"""
    Create a manager for the reverse side of a many-to-one relation.

    This manager subclasses another manager, generally the default manager of
    the related model, and adds behaviors specific to many-to-one relations.
    """"""

    class RelatedManager(superclass, AltersData):

        def __init__(self, instance):
            super().__init__()
            self.instance = instance
            self.model = rel.related_model
            self.field = rel.field
            self.core_filters = {self.field.name: instance}

        def __call__(self, *, manager):
            manager = getattr(self.model, manager)
            manager_class = create_reverse_many_to_one_manager(manager.__class__, rel)
            return manager_class(self.instance)
        do_not_call_in_templates = True

        def _check_fk_val(self):
            for field in self.field.foreign_related_fields:
                if getattr(self.instance, field.attname) is None:
                    raise ValueError(f'""{self.instance!r}"" needs to have a value for field ""{field.attname}"" before this relationship can be used.')

        def _apply_rel_filters(self, queryset):
            """"""
            Filter the queryset for the instance this manager is bound to.
            """"""
            db = self._db or router.db_for_read(self.model, instance=self.instance)
            empty_strings_as_null = connections[db].features.interprets_empty_strings_as_nulls
            queryset._add_hints(instance=self.instance)
            if self._db:
                queryset = queryset.using(self._db)
            queryset._defer_next_filter = True
            queryset = queryset.filter(**self.core_filters)
            for field in self.field.foreign_related_fields:
                val = getattr(self.instance, field.attname)
                if val is None or (val == '' and empty_strings_as_null):
                    return queryset.none()
            if self.field.many_to_one:
                try:
                    target_field = self.field.target_field
                except FieldError:
                    rel_obj_id = tuple([getattr(self.instance, target_field.attname) for target_field in self.field.path_infos[-1].target_fields])
                else:
                    rel_obj_id = getattr(self.instance, target_field.attname)
                queryset._known_related_objects = {self.field: {rel_obj_id: self.instance}}
            return queryset

        def _remove_prefetched_objects(self):
            try:
                self.instance._prefetched_objects_cache.pop(self.field.remote_field.get_cache_name())
            except (AttributeError, KeyError):
                pass

        def get_queryset(self):
            if self.instance.pk is None:
                raise ValueError(f'{self.instance.__class__.__name__!r} instance needs to have a primary key value before this relationship can be used.')
            try:
                return self.instance._prefetched_objects_cache[self.field.remote_field.get_cache_name()]
            except (AttributeError, KeyError):
                queryset = super().get_queryset()
                return self._apply_rel_filters(queryset)

        def get_prefetch_queryset(self, instances, queryset=None):
            if queryset is None:
                queryset = super().get_queryset()
            queryset._add_hints(instance=instances[0])
            queryset = queryset.using(queryset._db or self._db)
            rel_obj_attr = self.field.get_local_related_value
            instance_attr = self.field.get_foreign_related_value
            instances_dict = {instance_attr(inst): inst for inst in instances}
            queryset = _filter_prefetch_queryset(queryset, self.field.name, instances)
            for rel_obj in queryset:
                if not self.field.is_cached(rel_obj):
                    instance = instances_dict[rel_obj_attr(rel_obj)]
                    setattr(rel_obj, self.field.name, instance)
            cache_name = self.field.remote_field.get_cache_name()
            return (queryset, rel_obj_attr, instance_attr, False, cache_name, False)

        def add(self, *objs, bulk=True):
            self._check_fk_val()
            self._remove_prefetched_objects()
            db = router.db_for_write(self.model, instance=self.instance)

            def check_and_update_obj(obj):
                if not isinstance(obj, self.model):
                    raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
                setattr(obj, self.field.name, self.instance)
            if bulk:
                pks = []
                for obj in objs:
                    check_and_update_obj(obj)
                    if obj._state.adding or obj._state.db != db:
                        raise ValueError(""%r instance isn't saved. Use bulk=False or save the object first."" % obj)
                    pks.append(obj.pk)
                self.model._base_manager.using(db).filter(pk__in=pks).update(**{self.field.name: self.instance})
            else:
                with transaction.atomic(using=db, savepoint=False):
                    for obj in objs:
                        check_and_update_obj(obj)
                        obj.save()
        add.alters_data = True

        def create(self, **kwargs):
            self._check_fk_val()
            kwargs[self.field.name] = self.instance
            db = router.db_for_write(self.model, instance=self.instance)
            return super(RelatedManager, self.db_manager(db)).create(**kwargs)
        create.alters_data = True

        def get_or_create(self, **kwargs):
            self._check_fk_val()
            kwargs[self.field.name] = self.instance
            db = router.db_for_write(self.model, instance=self.instance)
            return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)
        get_or_create.alters_data = True

        def update_or_create(self, **kwargs):
            self._check_fk_val()
            kwargs[self.field.name] = self.instance
            db = router.db_for_write(self.model, instance=self.instance)
            return super(RelatedManager, self.db_manager(db)).update_or_create(**kwargs)
        update_or_create.alters_data = True
        if rel.field.null:

            def remove(self, *objs, bulk=True):
                if not objs:
                    return
                self._check_fk_val()
                val = self.field.get_foreign_related_value(self.instance)
                old_ids = set()
                for obj in objs:
                    if not isinstance(obj, self.model):
                        raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
                    if self.field.get_local_related_value(obj) == val:
                        old_ids.add(obj.pk)
                    else:
                        raise self.field.remote_field.model.DoesNotExist('%r is not related to %r.' % (obj, self.instance))
                self._clear(self.filter(pk__in=old_ids), bulk)
            remove.alters_data = True

            def clear(self, *, bulk=True):
                self._check_fk_val()
                self._clear(self, bulk)
            clear.alters_data = True

            def _clear(self, queryset, bulk):
                self._remove_prefetched_objects()
                db = router.db_for_write(self.model, instance=self.instance)
                queryset = queryset.using(db)
                if bulk:
                    queryset.update(**{self.field.name: None})
                else:
                    with transaction.atomic(using=db, savepoint=False):
                        for obj in queryset:
                            setattr(obj, self.field.name, None)
                            obj.save(update_fields=[self.field.name])
            _clear.alters_data = True

        def set(self, objs, *, bulk=True, clear=False):
            self._check_fk_val()
            objs = tuple(objs)
            if self.field.null:
                db = router.db_for_write(self.model, instance=self.instance)
                with transaction.atomic(using=db, savepoint=False):
                    if clear:
                        self.clear(bulk=bulk)
                        self.add(*objs, bulk=bulk)
                    else:
                        old_objs = set(self.using(db).all())
                        new_objs = []
                        for obj in objs:
                            if obj in old_objs:
                                old_objs.remove(obj)
                            else:
                                new_objs.append(obj)
                        self.remove(*old_objs, bulk=bulk)
                        self.add(*new_objs, bulk=bulk)
            else:
                self.add(*objs, bulk=bulk)
        set.alters_data = True
    return RelatedManager","[{""var"": ""val"", ""rename"": ""instance_foreign_key_value""}, {""var"": ""instance_attr"", ""rename"": ""related_instance_attribute""}, {""var"": ""new_objs"", ""rename"": ""new_related_objects""}, {""var"": ""field"", ""rename"": ""relationship_field""}, {""var"": ""do_not_call_in_templates"", ""rename"": ""disable_call_during_template_render""}, {""var"": ""pks"", ""rename"": ""primary_keys_to_update""}, {""var"": ""rel_obj"", ""rename"": ""related_object_manager""}, {""var"": ""inst"", ""rename"": ""related_instance""}, {""var"": ""instances_dict"", ""rename"": ""instances_by_foreign_key""}, {""var"": ""old_ids"", ""rename"": ""previous_object_ids""}, {""var"": ""db"", ""rename"": ""database_connection_alias""}, {""var"": ""target_field"", ""rename"": ""related_model_target_field""}, {""var"": ""old_objs"", ""rename"": ""existing_related_objects""}, {""var"": ""manager_class"", ""rename"": ""ReverseManyToOneRelatedManager""}, {""var"": ""rel_obj_attr"", ""rename"": ""related_object_attribute""}, {""var"": ""cache_name"", ""rename"": ""reverse_relation_cache_key""}, {""var"": ""empty_strings_as_null"", ""rename"": ""interprets_empty_strings_as_nulls""}, {""var"": ""rel_obj_id"", ""rename"": ""related_object_identifier""}]"
./django/db/models/fields/related_descriptors.py,create_forward_many_to_many_manager,initialize_many_to_many_relation_manager,941,1424,"def create_forward_many_to_many_manager(superclass, rel, reverse):
    """"""
    Create a manager for the either side of a many-to-many relation.

    This manager subclasses another manager, generally the default manager of
    the related model, and adds behaviors specific to many-to-many relations.
    """"""

    class ManyRelatedManager(superclass, AltersData):

        def __init__(self, instance=None):
            super().__init__()
            self.instance = instance
            if not reverse:
                self.model = rel.model
                self.query_field_name = rel.field.related_query_name()
                self.prefetch_cache_name = rel.field.name
                self.source_field_name = rel.field.m2m_field_name()
                self.target_field_name = rel.field.m2m_reverse_field_name()
                self.symmetrical = rel.symmetrical
            else:
                self.model = rel.related_model
                self.query_field_name = rel.field.name
                self.prefetch_cache_name = rel.field.related_query_name()
                self.source_field_name = rel.field.m2m_reverse_field_name()
                self.target_field_name = rel.field.m2m_field_name()
                self.symmetrical = False
            self.through = rel.through
            self.reverse = reverse
            self.source_field = self.through._meta.get_field(self.source_field_name)
            self.target_field = self.through._meta.get_field(self.target_field_name)
            self.core_filters = {}
            self.pk_field_names = {}
            for lh_field, rh_field in self.source_field.related_fields:
                core_filter_key = '%s__%s' % (self.query_field_name, rh_field.name)
                self.core_filters[core_filter_key] = getattr(instance, rh_field.attname)
                self.pk_field_names[lh_field.name] = rh_field.name
            self.related_val = self.source_field.get_foreign_related_value(instance)
            if None in self.related_val:
                raise ValueError('""%r"" needs to have a value for field ""%s"" before this many-to-many relationship can be used.' % (instance, self.pk_field_names[self.source_field_name]))
            if instance.pk is None:
                raise ValueError('%r instance needs to have a primary key value before a many-to-many relationship can be used.' % instance.__class__.__name__)

        def __call__(self, *, manager):
            manager = getattr(self.model, manager)
            manager_class = create_forward_many_to_many_manager(manager.__class__, rel, reverse)
            return manager_class(instance=self.instance)
        do_not_call_in_templates = True

        def _build_remove_filters(self, removed_vals):
            filters = Q.create([(self.source_field_name, self.related_val)])
            removed_vals_filters = not isinstance(removed_vals, QuerySet) or removed_vals._has_filters()
            if removed_vals_filters:
                filters &= Q.create([(f'{self.target_field_name}__in', removed_vals)])
            if self.symmetrical:
                symmetrical_filters = Q.create([(self.target_field_name, self.related_val)])
                if removed_vals_filters:
                    symmetrical_filters &= Q.create([(f'{self.source_field_name}__in', removed_vals)])
                filters |= symmetrical_filters
            return filters

        def _apply_rel_filters(self, queryset):
            """"""
            Filter the queryset for the instance this manager is bound to.
            """"""
            queryset._add_hints(instance=self.instance)
            if self._db:
                queryset = queryset.using(self._db)
            queryset._defer_next_filter = True
            return queryset._next_is_sticky().filter(**self.core_filters)

        def _remove_prefetched_objects(self):
            try:
                self.instance._prefetched_objects_cache.pop(self.prefetch_cache_name)
            except (AttributeError, KeyError):
                pass

        def get_queryset(self):
            try:
                return self.instance._prefetched_objects_cache[self.prefetch_cache_name]
            except (AttributeError, KeyError):
                queryset = super().get_queryset()
                return self._apply_rel_filters(queryset)

        def get_prefetch_queryset(self, instances, queryset=None):
            if queryset is None:
                queryset = super().get_queryset()
            queryset._add_hints(instance=instances[0])
            queryset = queryset.using(queryset._db or self._db)
            queryset = _filter_prefetch_queryset(queryset._next_is_sticky(), self.query_field_name, instances)
            fk = self.through._meta.get_field(self.source_field_name)
            join_table = fk.model._meta.db_table
            connection = connections[queryset.db]
            qn = connection.ops.quote_name
            queryset = queryset.extra(select={'_prefetch_related_val_%s' % f.attname: '%s.%s' % (qn(join_table), qn(f.column)) for f in fk.local_related_fields})
            return (queryset, lambda result: tuple((getattr(result, '_prefetch_related_val_%s' % f.attname) for f in fk.local_related_fields)), lambda inst: tuple((f.get_db_prep_value(getattr(inst, f.attname), connection) for f in fk.foreign_related_fields)), False, self.prefetch_cache_name, False)

        def add(self, *objs, through_defaults=None):
            self._remove_prefetched_objects()
            db = router.db_for_write(self.through, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                self._add_items(self.source_field_name, self.target_field_name, *objs, through_defaults=through_defaults)
                if self.symmetrical:
                    self._add_items(self.target_field_name, self.source_field_name, *objs, through_defaults=through_defaults)
        add.alters_data = True

        def remove(self, *objs):
            self._remove_prefetched_objects()
            self._remove_items(self.source_field_name, self.target_field_name, *objs)
        remove.alters_data = True

        def clear(self):
            db = router.db_for_write(self.through, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                signals.m2m_changed.send(sender=self.through, action='pre_clear', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=None, using=db)
                self._remove_prefetched_objects()
                filters = self._build_remove_filters(super().get_queryset().using(db))
                self.through._default_manager.using(db).filter(filters).delete()
                signals.m2m_changed.send(sender=self.through, action='post_clear', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=None, using=db)
        clear.alters_data = True

        def set(self, objs, *, clear=False, through_defaults=None):
            objs = tuple(objs)
            db = router.db_for_write(self.through, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                if clear:
                    self.clear()
                    self.add(*objs, through_defaults=through_defaults)
                else:
                    old_ids = set(self.using(db).values_list(self.target_field.target_field.attname, flat=True))
                    new_objs = []
                    for obj in objs:
                        fk_val = self.target_field.get_foreign_related_value(obj)[0] if isinstance(obj, self.model) else self.target_field.get_prep_value(obj)
                        if fk_val in old_ids:
                            old_ids.remove(fk_val)
                        else:
                            new_objs.append(obj)
                    self.remove(*old_ids)
                    self.add(*new_objs, through_defaults=through_defaults)
        set.alters_data = True

        def create(self, *, through_defaults=None, **kwargs):
            db = router.db_for_write(self.instance.__class__, instance=self.instance)
            new_obj = super(ManyRelatedManager, self.db_manager(db)).create(**kwargs)
            self.add(new_obj, through_defaults=through_defaults)
            return new_obj
        create.alters_data = True

        def get_or_create(self, *, through_defaults=None, **kwargs):
            db = router.db_for_write(self.instance.__class__, instance=self.instance)
            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(**kwargs)
            if created:
                self.add(obj, through_defaults=through_defaults)
            return (obj, created)
        get_or_create.alters_data = True

        def update_or_create(self, *, through_defaults=None, **kwargs):
            db = router.db_for_write(self.instance.__class__, instance=self.instance)
            obj, created = super(ManyRelatedManager, self.db_manager(db)).update_or_create(**kwargs)
            if created:
                self.add(obj, through_defaults=through_defaults)
            return (obj, created)
        update_or_create.alters_data = True

        def _get_target_ids(self, target_field_name, objs):
            """"""
            Return the set of ids of `objs` that the target field references.
            """"""
            from django.db.models import Model
            target_ids = set()
            target_field = self.through._meta.get_field(target_field_name)
            for obj in objs:
                if isinstance(obj, self.model):
                    if not router.allow_relation(obj, self.instance):
                        raise ValueError('Cannot add ""%r"": instance is on database ""%s"", value is on database ""%s""' % (obj, self.instance._state.db, obj._state.db))
                    target_id = target_field.get_foreign_related_value(obj)[0]
                    if target_id is None:
                        raise ValueError('Cannot add ""%r"": the value for field ""%s"" is None' % (obj, target_field_name))
                    target_ids.add(target_id)
                elif isinstance(obj, Model):
                    raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
                else:
                    target_ids.add(target_field.get_prep_value(obj))
            return target_ids

        def _get_missing_target_ids(self, source_field_name, target_field_name, db, target_ids):
            """"""
            Return the subset of ids of `objs` that aren't already assigned to
            this relationship.
            """"""
            vals = self.through._default_manager.using(db).values_list(target_field_name, flat=True).filter(**{source_field_name: self.related_val[0], '%s__in' % target_field_name: target_ids})
            return target_ids.difference(vals)

        def _get_add_plan(self, db, source_field_name):
            """"""
            Return a boolean triple of the way the add should be performed.

            The first element is whether or not bulk_create(ignore_conflicts)
            can be used, the second whether or not signals must be sent, and
            the third element is whether or not the immediate bulk insertion
            with conflicts ignored can be performed.
            """"""
            can_ignore_conflicts = self.through._meta.auto_created is not False and connections[db].features.supports_ignore_conflicts
            must_send_signals = (self.reverse or source_field_name == self.source_field_name) and signals.m2m_changed.has_listeners(self.through)
            return (can_ignore_conflicts, must_send_signals, can_ignore_conflicts and (not must_send_signals))

        def _add_items(self, source_field_name, target_field_name, *objs, through_defaults=None):
            if not objs:
                return
            through_defaults = dict(resolve_callables(through_defaults or {}))
            target_ids = self._get_target_ids(target_field_name, objs)
            db = router.db_for_write(self.through, instance=self.instance)
            can_ignore_conflicts, must_send_signals, can_fast_add = self._get_add_plan(db, source_field_name)
            if can_fast_add:
                self.through._default_manager.using(db).bulk_create([self.through(**{'%s_id' % source_field_name: self.related_val[0], '%s_id' % target_field_name: target_id}) for target_id in target_ids], ignore_conflicts=True)
                return
            missing_target_ids = self._get_missing_target_ids(source_field_name, target_field_name, db, target_ids)
            with transaction.atomic(using=db, savepoint=False):
                if must_send_signals:
                    signals.m2m_changed.send(sender=self.through, action='pre_add', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=missing_target_ids, using=db)
                self.through._default_manager.using(db).bulk_create([self.through(**through_defaults, **{'%s_id' % source_field_name: self.related_val[0], '%s_id' % target_field_name: target_id}) for target_id in missing_target_ids], ignore_conflicts=can_ignore_conflicts)
                if must_send_signals:
                    signals.m2m_changed.send(sender=self.through, action='post_add', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=missing_target_ids, using=db)

        def _remove_items(self, source_field_name, target_field_name, *objs):
            if not objs:
                return
            old_ids = set()
            for obj in objs:
                if isinstance(obj, self.model):
                    fk_val = self.target_field.get_foreign_related_value(obj)[0]
                    old_ids.add(fk_val)
                else:
                    old_ids.add(obj)
            db = router.db_for_write(self.through, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                signals.m2m_changed.send(sender=self.through, action='pre_remove', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=old_ids, using=db)
                target_model_qs = super().get_queryset()
                if target_model_qs._has_filters():
                    old_vals = target_model_qs.using(db).filter(**{'%s__in' % self.target_field.target_field.attname: old_ids})
                else:
                    old_vals = old_ids
                filters = self._build_remove_filters(old_vals)
                self.through._default_manager.using(db).filter(filters).delete()
                signals.m2m_changed.send(sender=self.through, action='post_remove', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=old_ids, using=db)
    return ManyRelatedManager","def initialize_many_to_many_relation_manager(superclass, rel, reverse):
    """"""
    Create a manager for the either side of a many-to-many relation.

    This manager subclasses another manager, generally the default manager of
    the related model, and adds behaviors specific to many-to-many relations.
    """"""

    class ManyRelatedManager(superclass, AltersData):

        def __init__(self, instance=None):
            super().__init__()
            self.instance = instance
            if not reverse:
                self.model = rel.model
                self.query_field_name = rel.field.related_query_name()
                self.prefetch_cache_name = rel.field.name
                self.source_field_name = rel.field.m2m_field_name()
                self.target_field_name = rel.field.m2m_reverse_field_name()
                self.symmetrical = rel.symmetrical
            else:
                self.model = rel.related_model
                self.query_field_name = rel.field.name
                self.prefetch_cache_name = rel.field.related_query_name()
                self.source_field_name = rel.field.m2m_reverse_field_name()
                self.target_field_name = rel.field.m2m_field_name()
                self.symmetrical = False
            self.through = rel.through
            self.reverse = reverse
            self.source_field = self.through._meta.get_field(self.source_field_name)
            self.target_field = self.through._meta.get_field(self.target_field_name)
            self.core_filters = {}
            self.pk_field_names = {}
            for lh_field, rh_field in self.source_field.related_fields:
                core_filter_key = '%s__%s' % (self.query_field_name, rh_field.name)
                self.core_filters[core_filter_key] = getattr(instance, rh_field.attname)
                self.pk_field_names[lh_field.name] = rh_field.name
            self.related_val = self.source_field.get_foreign_related_value(instance)
            if None in self.related_val:
                raise ValueError('""%r"" needs to have a value for field ""%s"" before this many-to-many relationship can be used.' % (instance, self.pk_field_names[self.source_field_name]))
            if instance.pk is None:
                raise ValueError('%r instance needs to have a primary key value before a many-to-many relationship can be used.' % instance.__class__.__name__)

        def __call__(self, *, manager):
            manager = getattr(self.model, manager)
            manager_class = create_forward_many_to_many_manager(manager.__class__, rel, reverse)
            return manager_class(instance=self.instance)
        do_not_call_in_templates = True

        def _build_remove_filters(self, removed_vals):
            filters = Q.create([(self.source_field_name, self.related_val)])
            removed_vals_filters = not isinstance(removed_vals, QuerySet) or removed_vals._has_filters()
            if removed_vals_filters:
                filters &= Q.create([(f'{self.target_field_name}__in', removed_vals)])
            if self.symmetrical:
                symmetrical_filters = Q.create([(self.target_field_name, self.related_val)])
                if removed_vals_filters:
                    symmetrical_filters &= Q.create([(f'{self.source_field_name}__in', removed_vals)])
                filters |= symmetrical_filters
            return filters

        def _apply_rel_filters(self, queryset):
            """"""
            Filter the queryset for the instance this manager is bound to.
            """"""
            queryset._add_hints(instance=self.instance)
            if self._db:
                queryset = queryset.using(self._db)
            queryset._defer_next_filter = True
            return queryset._next_is_sticky().filter(**self.core_filters)

        def _remove_prefetched_objects(self):
            try:
                self.instance._prefetched_objects_cache.pop(self.prefetch_cache_name)
            except (AttributeError, KeyError):
                pass

        def get_queryset(self):
            try:
                return self.instance._prefetched_objects_cache[self.prefetch_cache_name]
            except (AttributeError, KeyError):
                queryset = super().get_queryset()
                return self._apply_rel_filters(queryset)

        def get_prefetch_queryset(self, instances, queryset=None):
            if queryset is None:
                queryset = super().get_queryset()
            queryset._add_hints(instance=instances[0])
            queryset = queryset.using(queryset._db or self._db)
            queryset = _filter_prefetch_queryset(queryset._next_is_sticky(), self.query_field_name, instances)
            fk = self.through._meta.get_field(self.source_field_name)
            join_table = fk.model._meta.db_table
            connection = connections[queryset.db]
            qn = connection.ops.quote_name
            queryset = queryset.extra(select={'_prefetch_related_val_%s' % f.attname: '%s.%s' % (qn(join_table), qn(f.column)) for f in fk.local_related_fields})
            return (queryset, lambda result: tuple((getattr(result, '_prefetch_related_val_%s' % f.attname) for f in fk.local_related_fields)), lambda inst: tuple((f.get_db_prep_value(getattr(inst, f.attname), connection) for f in fk.foreign_related_fields)), False, self.prefetch_cache_name, False)

        def add(self, *objs, through_defaults=None):
            self._remove_prefetched_objects()
            db = router.db_for_write(self.through, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                self._add_items(self.source_field_name, self.target_field_name, *objs, through_defaults=through_defaults)
                if self.symmetrical:
                    self._add_items(self.target_field_name, self.source_field_name, *objs, through_defaults=through_defaults)
        add.alters_data = True

        def remove(self, *objs):
            self._remove_prefetched_objects()
            self._remove_items(self.source_field_name, self.target_field_name, *objs)
        remove.alters_data = True

        def clear(self):
            db = router.db_for_write(self.through, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                signals.m2m_changed.send(sender=self.through, action='pre_clear', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=None, using=db)
                self._remove_prefetched_objects()
                filters = self._build_remove_filters(super().get_queryset().using(db))
                self.through._default_manager.using(db).filter(filters).delete()
                signals.m2m_changed.send(sender=self.through, action='post_clear', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=None, using=db)
        clear.alters_data = True

        def set(self, objs, *, clear=False, through_defaults=None):
            objs = tuple(objs)
            db = router.db_for_write(self.through, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                if clear:
                    self.clear()
                    self.add(*objs, through_defaults=through_defaults)
                else:
                    old_ids = set(self.using(db).values_list(self.target_field.target_field.attname, flat=True))
                    new_objs = []
                    for obj in objs:
                        fk_val = self.target_field.get_foreign_related_value(obj)[0] if isinstance(obj, self.model) else self.target_field.get_prep_value(obj)
                        if fk_val in old_ids:
                            old_ids.remove(fk_val)
                        else:
                            new_objs.append(obj)
                    self.remove(*old_ids)
                    self.add(*new_objs, through_defaults=through_defaults)
        set.alters_data = True

        def create(self, *, through_defaults=None, **kwargs):
            db = router.db_for_write(self.instance.__class__, instance=self.instance)
            new_obj = super(ManyRelatedManager, self.db_manager(db)).create(**kwargs)
            self.add(new_obj, through_defaults=through_defaults)
            return new_obj
        create.alters_data = True

        def get_or_create(self, *, through_defaults=None, **kwargs):
            db = router.db_for_write(self.instance.__class__, instance=self.instance)
            obj, created = super(ManyRelatedManager, self.db_manager(db)).get_or_create(**kwargs)
            if created:
                self.add(obj, through_defaults=through_defaults)
            return (obj, created)
        get_or_create.alters_data = True

        def update_or_create(self, *, through_defaults=None, **kwargs):
            db = router.db_for_write(self.instance.__class__, instance=self.instance)
            obj, created = super(ManyRelatedManager, self.db_manager(db)).update_or_create(**kwargs)
            if created:
                self.add(obj, through_defaults=through_defaults)
            return (obj, created)
        update_or_create.alters_data = True

        def _get_target_ids(self, target_field_name, objs):
            """"""
            Return the set of ids of `objs` that the target field references.
            """"""
            from django.db.models import Model
            target_ids = set()
            target_field = self.through._meta.get_field(target_field_name)
            for obj in objs:
                if isinstance(obj, self.model):
                    if not router.allow_relation(obj, self.instance):
                        raise ValueError('Cannot add ""%r"": instance is on database ""%s"", value is on database ""%s""' % (obj, self.instance._state.db, obj._state.db))
                    target_id = target_field.get_foreign_related_value(obj)[0]
                    if target_id is None:
                        raise ValueError('Cannot add ""%r"": the value for field ""%s"" is None' % (obj, target_field_name))
                    target_ids.add(target_id)
                elif isinstance(obj, Model):
                    raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
                else:
                    target_ids.add(target_field.get_prep_value(obj))
            return target_ids

        def _get_missing_target_ids(self, source_field_name, target_field_name, db, target_ids):
            """"""
            Return the subset of ids of `objs` that aren't already assigned to
            this relationship.
            """"""
            vals = self.through._default_manager.using(db).values_list(target_field_name, flat=True).filter(**{source_field_name: self.related_val[0], '%s__in' % target_field_name: target_ids})
            return target_ids.difference(vals)

        def _get_add_plan(self, db, source_field_name):
            """"""
            Return a boolean triple of the way the add should be performed.

            The first element is whether or not bulk_create(ignore_conflicts)
            can be used, the second whether or not signals must be sent, and
            the third element is whether or not the immediate bulk insertion
            with conflicts ignored can be performed.
            """"""
            can_ignore_conflicts = self.through._meta.auto_created is not False and connections[db].features.supports_ignore_conflicts
            must_send_signals = (self.reverse or source_field_name == self.source_field_name) and signals.m2m_changed.has_listeners(self.through)
            return (can_ignore_conflicts, must_send_signals, can_ignore_conflicts and (not must_send_signals))

        def _add_items(self, source_field_name, target_field_name, *objs, through_defaults=None):
            if not objs:
                return
            through_defaults = dict(resolve_callables(through_defaults or {}))
            target_ids = self._get_target_ids(target_field_name, objs)
            db = router.db_for_write(self.through, instance=self.instance)
            can_ignore_conflicts, must_send_signals, can_fast_add = self._get_add_plan(db, source_field_name)
            if can_fast_add:
                self.through._default_manager.using(db).bulk_create([self.through(**{'%s_id' % source_field_name: self.related_val[0], '%s_id' % target_field_name: target_id}) for target_id in target_ids], ignore_conflicts=True)
                return
            missing_target_ids = self._get_missing_target_ids(source_field_name, target_field_name, db, target_ids)
            with transaction.atomic(using=db, savepoint=False):
                if must_send_signals:
                    signals.m2m_changed.send(sender=self.through, action='pre_add', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=missing_target_ids, using=db)
                self.through._default_manager.using(db).bulk_create([self.through(**through_defaults, **{'%s_id' % source_field_name: self.related_val[0], '%s_id' % target_field_name: target_id}) for target_id in missing_target_ids], ignore_conflicts=can_ignore_conflicts)
                if must_send_signals:
                    signals.m2m_changed.send(sender=self.through, action='post_add', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=missing_target_ids, using=db)

        def _remove_items(self, source_field_name, target_field_name, *objs):
            if not objs:
                return
            old_ids = set()
            for obj in objs:
                if isinstance(obj, self.model):
                    fk_val = self.target_field.get_foreign_related_value(obj)[0]
                    old_ids.add(fk_val)
                else:
                    old_ids.add(obj)
            db = router.db_for_write(self.through, instance=self.instance)
            with transaction.atomic(using=db, savepoint=False):
                signals.m2m_changed.send(sender=self.through, action='pre_remove', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=old_ids, using=db)
                target_model_qs = super().get_queryset()
                if target_model_qs._has_filters():
                    old_vals = target_model_qs.using(db).filter(**{'%s__in' % self.target_field.target_field.attname: old_ids})
                else:
                    old_vals = old_ids
                filters = self._build_remove_filters(old_vals)
                self.through._default_manager.using(db).filter(filters).delete()
                signals.m2m_changed.send(sender=self.through, action='post_remove', instance=self.instance, reverse=self.reverse, model=self.model, pk_set=old_ids, using=db)
    return ManyRelatedManager","[{""var"": ""filters"", ""rename"": ""many_to_many_removal_filters""}, {""var"": ""target_model_qs"", ""rename"": ""related_model_queryset""}, {""var"": ""fk_val"", ""rename"": ""foreign_key_value""}, {""var"": ""new_obj"", ""rename"": ""forward_m2m_manager_instance""}, {""var"": ""obj"", ""rename"": ""manyToManyManagerInstance""}, {""var"": ""can_fast_add"", ""rename"": ""can_perform_bulk_addition""}, {""var"": ""must_send_signals"", ""rename"": ""requires_signal_dispatch""}, {""var"": ""missing_target_ids"", ""rename"": ""unlinked_target_ids""}, {""var"": ""do_not_call_in_templates"", ""rename"": ""suppress_template_call""}, {""var"": ""db"", ""rename"": ""database_connection""}, {""var"": ""removed_vals_filters"", ""rename"": ""has_removed_values_filters""}, {""var"": ""fk"", ""rename"": ""foreignKeyField""}, {""var"": ""target_id"", ""rename"": ""relationship_target_identifier""}, {""var"": ""new_objs"", ""rename"": ""new_related_objects""}, {""var"": ""join_table"", ""rename"": ""m2m_join_table_name""}, {""var"": ""vals"", ""rename"": ""missingTargetIDs""}, {""var"": ""target_ids"", ""rename"": ""related_entity_ids""}, {""var"": ""symmetrical_filters"", ""rename"": ""bidirectional_relation_filters""}, {""var"": ""core_filter_key"", ""rename"": ""relation_attribute_filter_key""}, {""var"": ""target_field"", ""rename"": ""target_relation_field_name""}, {""var"": ""manager_class"", ""rename"": ""ForwardManyToManyManagerClass""}, {""var"": ""rh_field"", ""rename"": ""related_right_field""}, {""var"": ""qn"", ""rename"": ""quote_name_function""}, {""var"": ""can_ignore_conflicts"", ""rename"": ""allow_ignore_conflict_during_addition""}, {""var"": ""created"", ""rename"": ""forward_many_to_many_manager""}, {""var"": ""connection"", ""rename"": ""database_connection""}, {""var"": ""f"", ""rename"": ""forward_many_to_many_manager_creator""}, {""var"": ""old_ids"", ""rename"": ""existing_member_ids""}, {""var"": ""old_vals"", ""rename"": ""former_associated_ids""}, {""var"": ""lh_field"", ""rename"": ""left_hand_field""}]"
./django/db/models/fields/related_descriptors.py,get_or_create,fetch_or_initialize_related_instance,796,800,"def get_or_create(self, **kwargs):
    self._check_fk_val()
    kwargs[self.field.name] = self.instance
    db = router.db_for_write(self.model, instance=self.instance)
    return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)","def fetch_or_initialize_related_instance(self, **kwargs):
    self._check_fk_val()
    kwargs[self.field.name] = self.instance
    db = router.db_for_write(self.model, instance=self.instance)
    return super(RelatedManager, self.db_manager(db)).get_or_create(**kwargs)","[{""var"": ""db"", ""rename"": ""database_for_write_operation""}]"
./django/db/models/fields/related_descriptors.py,update_or_create,ensure_existence_or_update_related,1207,1216,"def update_or_create(self, *, through_defaults=None, **kwargs):
    db = router.db_for_write(self.instance.__class__, instance=self.instance)
    obj, created = super(ManyRelatedManager, self.db_manager(db)).update_or_create(**kwargs)
    if created:
        self.add(obj, through_defaults=through_defaults)
    return (obj, created)","def ensure_existence_or_update_related(self, *, through_defaults=None, **kwargs):
    db = router.db_for_write(self.instance.__class__, instance=self.instance)
    obj, created = super(ManyRelatedManager, self.db_manager(db)).update_or_create(**kwargs)
    if created:
        self.add(obj, through_defaults=through_defaults)
    return (obj, created)","[{""var"": ""created"", ""rename"": ""was_object_created""}, {""var"": ""db"", ""rename"": ""database_for_instance_write""}, {""var"": ""obj"", ""rename"": ""related_instance""}]"
./django/db/models/fields/related_descriptors.py,_get_target_ids,extract_foreign_relation_ids,1220,1250,"def _get_target_ids(self, target_field_name, objs):
    """"""
            Return the set of ids of `objs` that the target field references.
            """"""
    from django.db.models import Model
    target_ids = set()
    target_field = self.through._meta.get_field(target_field_name)
    for obj in objs:
        if isinstance(obj, self.model):
            if not router.allow_relation(obj, self.instance):
                raise ValueError('Cannot add ""%r"": instance is on database ""%s"", value is on database ""%s""' % (obj, self.instance._state.db, obj._state.db))
            target_id = target_field.get_foreign_related_value(obj)[0]
            if target_id is None:
                raise ValueError('Cannot add ""%r"": the value for field ""%s"" is None' % (obj, target_field_name))
            target_ids.add(target_id)
        elif isinstance(obj, Model):
            raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
        else:
            target_ids.add(target_field.get_prep_value(obj))
    return target_ids","def extract_foreign_relation_ids(self, target_field_name, objs):
    """"""
            Return the set of ids of `objs` that the target field references.
            """"""
    from django.db.models import Model
    target_ids = set()
    target_field = self.through._meta.get_field(target_field_name)
    for obj in objs:
        if isinstance(obj, self.model):
            if not router.allow_relation(obj, self.instance):
                raise ValueError('Cannot add ""%r"": instance is on database ""%s"", value is on database ""%s""' % (obj, self.instance._state.db, obj._state.db))
            target_id = target_field.get_foreign_related_value(obj)[0]
            if target_id is None:
                raise ValueError('Cannot add ""%r"": the value for field ""%s"" is None' % (obj, target_field_name))
            target_ids.add(target_id)
        elif isinstance(obj, Model):
            raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
        else:
            target_ids.add(target_field.get_prep_value(obj))
    return target_ids","[{""var"": ""target_field"", ""rename"": ""reference_field""}, {""var"": ""target_ids"", ""rename"": ""referenced_object_ids""}, {""var"": ""obj"", ""rename"": ""target_related_object""}, {""var"": ""target_id"", ""rename"": ""referenced_object_id""}]"
./django/db/models/fields/related_descriptors.py,_get_missing_target_ids,identify_unlinked_target_ids,1252,1269,"def _get_missing_target_ids(self, source_field_name, target_field_name, db, target_ids):
    """"""
            Return the subset of ids of `objs` that aren't already assigned to
            this relationship.
            """"""
    vals = self.through._default_manager.using(db).values_list(target_field_name, flat=True).filter(**{source_field_name: self.related_val[0], '%s__in' % target_field_name: target_ids})
    return target_ids.difference(vals)","def identify_unlinked_target_ids(self, source_field_name, target_field_name, db, target_ids):
    """"""
            Return the subset of ids of `objs` that aren't already assigned to
            this relationship.
            """"""
    vals = self.through._default_manager.using(db).values_list(target_field_name, flat=True).filter(**{source_field_name: self.related_val[0], '%s__in' % target_field_name: target_ids})
    return target_ids.difference(vals)","[{""var"": ""vals"", ""rename"": ""existing_assigned_target_ids""}]"
./django/db/models/fields/related_descriptors.py,remove,remove_related_objects,816,838,"def remove(self, *objs, bulk=True):
    if not objs:
        return
    self._check_fk_val()
    val = self.field.get_foreign_related_value(self.instance)
    old_ids = set()
    for obj in objs:
        if not isinstance(obj, self.model):
            raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
        if self.field.get_local_related_value(obj) == val:
            old_ids.add(obj.pk)
        else:
            raise self.field.remote_field.model.DoesNotExist('%r is not related to %r.' % (obj, self.instance))
    self._clear(self.filter(pk__in=old_ids), bulk)","def remove_related_objects(self, *objs, bulk=True):
    if not objs:
        return
    self._check_fk_val()
    val = self.field.get_foreign_related_value(self.instance)
    old_ids = set()
    for obj in objs:
        if not isinstance(obj, self.model):
            raise TypeError(""'%s' instance expected, got %r"" % (self.model._meta.object_name, obj))
        if self.field.get_local_related_value(obj) == val:
            old_ids.add(obj.pk)
        else:
            raise self.field.remote_field.model.DoesNotExist('%r is not related to %r.' % (obj, self.instance))
    self._clear(self.filter(pk__in=old_ids), bulk)","[{""var"": ""old_ids"", ""rename"": ""unrelated_object_ids""}, {""var"": ""val"", ""rename"": ""instance_foreign_value""}, {""var"": ""obj"", ""rename"": ""related_object""}]"
